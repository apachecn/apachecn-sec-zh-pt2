# 十一、分组密码

本章涵盖

*   DES 和 AES 的加密标准
*   基于矩阵乘法的密码
*   加密和解密完全相同的对合密码
*   波纹密码
*   块链接

我们已经看到了几种对分成字符块的文本进行运算的密码。有些只对 2 或 3 个字符的小方块进行操作，如 Playfair 、两方块 、三方块 和四方块 。有些对更长的块进行操作，但一次只改变 2 或 3 个字符，如双歧 、三歧 或 FR-actioned Morse。 这些密码只在每个块的一部分上局部作用。明文中一个字符的改变通常最多改变密文的 2 或 3 个字符。

这一章讨论更强类型的分组密码。在这些密码中，即使改变明文的一个位元，或是金钥的一个位元，都会改变大约一半的密文位元，以及几乎所有的密文位元组。这表明密码是高度非线性的(见 12.3 节)。这些密码仅供计算机使用，通常使用专用硬件来加速加密。

这本书的大部分内容都与计算机密码和方法有关。如果你不关心计算机方法，简单地跳过那些部分。

## 11.1 替代-置换网络

许多 分组密码采取的是*置换网络* (SPN)的形式。这个想法是由 IBM 的 Horst Feistel 在 1971 年首次提出的。加密由几轮组成，每轮可能由一个或多个替换步骤和/或一个或多个置换步骤组成。通常有一个控制整体操作的主键。

替换步骤最常见的选择是(1)简单替换 , (2)部分块与部分密钥的异或运算，或(3)在密钥控制下的多字母替换。密钥可以由取自主密钥的比特和/或取自未被替换的块的一部分的比特组成。例如，块中奇数编号的字节可以用作密钥来加密偶数编号的字节，反之亦然。一种稍微复杂一点的替换形式是从密钥中取出一些位，将它们与块中相同数量的位进行异或运算，并将结果用作多字母密钥来替换块的不同部分。

替换字母通常是事先选定的，从不改变。这些被称为 *S 盒*T3。它们可能是简单的替换，也可能是多字母替换，所以 S 盒在计算机上相当于一个表格。它们通常用 4 到 8 个关键位来选择表的行，用块的 4 或 8 位作为输入，用相同数量的位作为输出。通常一些复杂的数学会被用于替代字母表的构建。特别是，字母表被设计成非线性的，这在第 12.3 节中有详细说明。

每一轮的排列通常也是预先确定的，不会改变。置换可以在单个比特、4 比特组或 8 比特字节的单元上操作。在大多数分组密码中，没有用于排列的密钥；它们被硬编码在软件中或硬连接到加密芯片中。

最早的现代分组密码是由 IBM 的霍斯特·费斯特尔设计的路西法。在 Feistel 选定 Lucifer 之前，这个名字被改了好几次，因为他想要一个能体现这个设计邪恶本质的名字。Feistel 还反复更改了 Lucifer 的设计，从最初的在 128 位块上工作的 48 位密钥改为在 128 位块上工作的 128 位密钥。你可以在 https://derekbruff.org/blogs/fywscrypto/tag/lucifer[阅读更多关于路西法的信息(2022 年 5 月访问)。](https://derekbruff.org/blogs/fywscrypto/tag/lucifer)

这是一个微型置换网络密码的示意图。这个密码接受一个 16 位的明文并产生一个 16 位的密文。它有 4 个替换回合和 3 个换位回合。替换和置换是固定的；它们内置于硬件中。使用了 4 种不同的替换，S <sub class="fm-subscript">1</sub> ，S <sub class="fm-subscript">2</sub> ，S <sub class="fm-subscript">3</sub> 和 S <sub class="fm-subscript">4</sub> 。每次替换需要 4 个输入位加上一个密钥，K <sub class="fm-subscript">11</sub> 到 K <sub class="fm-subscript">44</sub> ，通常是 4、6 或 8 位，因此如果所有的密钥都是独立的，密码可能有 64、96 或 128 个密钥位。每一轮的换位是不同的。

![11-unnumb-1](img/11-unnumb-1.png)

这个迷你网络密码 被评为三级，因为它相当于一个二元组替换，但它可以用 6 个替换轮从 16 位扩大到 64 位，被评为八级，或者用 8 个替换轮从 128 位被评为十级。

Lucifer 最终版本的设计直接导致了 1977 年美国国家标准局 (NBS)正式采用的 *数据加密标准* (DES ) 。因此，我们直接跳到 吧。

## 11.2 数据加密标准(DES)

DES 是 IBM 于 1976 年通过精简当时的路西法版本开发的。那个版本使用 128 位的密钥，处理 128 位的信息块。块大小减少到 64 位，这是合理的，因为这降低了硬件成本。IBM 想使用 64 位密钥，但 NSA 坚持将密钥进一步减少到 56 位，理由是多余的 8 位可以用作校验和。人们普遍认为，实际原因是国家安全局有能力解决 56 位 DES，但没有 64 位 DES。

IBM 原本计划把 DES 做成 6 轮密码。当 NSA 告诉 IBM 它可以破解 6 轮版本时，IBM 直接跳到了 16 轮，与 Feistel 在他的最终版本 Lucifer 中使用的轮数相同。

DES 的一个新特性，在路西法 的任何版本中都没有，就是在第一个替换步骤之前和最后一个替换步骤之后有一个 位换位。这些是 8×8 列转置 ，其中列的顺序和行的顺序都被改变。对于初始转置，块的 64 位从左到右写入网格。列以相反的顺序读出，即 8，7，6，5，4，3，2，1。按照 2，4，6，8，1，3，5，7 的顺序读出这些行。最后的换位与此相反。

这些换位没有密码价值。他们没有增加 DES 的力量。之所以添加它们，是因为 NSA 告诉 IBM 加密在硬件中进行时应该很快，但在软件中模拟时会很慢。这个想法是为了让艾米丽用暴力破解密码更费时间，也就是说，通过尝试软件中所有可能的密钥。IBM 认为置换位会使任何软件实现都非常慢。IBM 可能设想了一个过程，通过屏蔽一个接一个地提取比特，然后移位到适当的位置。

这被证明是完全错误的。首先，想要破解 DES 的敌人可以通过代理购买加密芯片。其次，对于一些合法的应用程序，DES 需要嵌入到软件中，所以软件必须很快。第三，比特置换可以快速完成，无需提取单个比特或移位。我将在 11.2.3 节中展示如何操作。

在最初和最后的置换之间，DES 有 16 轮置换。64 位块被分成两半 32 位。在每一轮中，右半边用来加密左半边。右半部分首先从 32 位扩展到 48 位，如下所示。这 32 位被视为 8 个 4 位组。通过附加取自相邻组的前一位和后一位，这些组中的每一组从 4 位扩展到 6 位。例如，第三组由第 9 位到第 12 位组成。通过将位 8 附加到左边并将位 13 附加到右边，这个 4 位组将从 4 位扩展到 6 位。换句话说，6 位组将是 8、9、10、11、12、13 位。八个这样的 6 位组形成一个 48 位块。

然后，这个 48 位块与从 56 位密钥中取出的 48 位进行异或运算。每一轮使用哪 48 位由一个*密钥表* 决定，它基本上是在每一轮后将完整的 56 位密钥移动几个位置。然后将得到的八个 6 位组送入八个固定的 S 盒，即替换。每个 S 盒给出一个 4 位结果，因此 8 个 4 位结果合在一起形成一个 32 位块。然后，该块与整个 64 位块的左半部分进行异或运算。

抛开历史不谈

IBM 没有为 DES 设计一个关键的时间表。最初的想法是在 16 轮中的每一轮之后，将 64 位密钥循环 4 位位置。这样就把密钥留在了原来的位置，准备加密下一个块。当 NSA 让 IBM 将密钥大小减少到 56 位时，IBM 被迫引入密钥表。四位移位不再有效。当然，IBM 称关键时间表为“特性”

查看每个 S 盒的另一种方法是将它想象成一个 4×16 的画面。像 Belaso 或 Vigenère tableau 一样，每一行都是 4 位组的替换表。附加到 4 位组的两个额外的位用于选择使用表的 4 行中的哪一行。

每个 S 盒都经过精心设计，使得 6 个输入位和 4 个输出位之间的相关性尽可能小。国家安全局已经找到了一种绝密的方法来设计 S 盒，以给出尽可能最低的相关性。因为 DES 如此重要，NSA 决定与 DES 的 IBM 设计者分享这个机密。然而，在检查了 IBM 的设计后，NSA 意识到 IBM 也发现了这种方法，并在其设计中使用了这种方法。

在每一轮之后，除了最后一轮，64 位块的左半部分和右半部分被交换。

### 11.2.1 双 DES

It 从一开始就明白，56 位的密钥对于强大的安全性来说太小了。在 DES 被采用仅 4 个月后，电子前沿基金会建造了一台价值 25 万美元的专用计算机，名为 Deep Crack ，仅用 56 小时就破解了一条 DES 信息。

针对这一明显弱点的第一个解决方案是使用两个不同的密钥用 DES 对一条消息加密两次。这个想法被否决了，因为理论上可以发起一次中间相遇攻击来破解 DES。也就是说，你从明文向前工作，从密文向后工作，在中间相遇。要做到这一点，您需要获取一个明文已知的密文块。你用所有 2 个 <sup class="fm-superscript">56 个</sup>可能的密钥加密明文，然后用所有 2 个 <sup class="fm-superscript">56 个</sup>可能的密钥解密密文。你比较这些结果，无论你在哪里找到匹配，你就有了一对可能的钥匙。

这次攻击只是理论上的。你需要存储 2 组 2 个 <sup class="fm-superscript">56 个</sup>解，也就是 2 个 <sup class="fm-superscript">60 个</sup>字节，来进行所有的比较。在 20 世纪 70 年代，没有一台计算机能达到这样的存储水平。此外，您预计大约有 2 个 <sup class="fm-superscript">48 个</sup>匹配。这些都需要检查。这是一项艰巨的任务。但是 IBM 和美国国家安全局希望 DES 能持续 20 到 30 年，这种攻击在这段时间内变得可行是有可能的。可能会使用双 DES，但它从未被接受为一个 标准。

### 11.2.2 三重 DES

*三重 DES* ，或 *3DES* ，是对 DES 较小的 56 位密钥大小的又一次尝试。它包括获取一个 64 位数据块，用一个 DES 密钥对其加密，用第二个 DES 密钥对其解密，然后用第三个 DES 密钥对其加密。显然，这比普通 DES 要花 3 倍的时间。它没有被广泛使用，因为这使得它非常慢。

有一种更快的方法来提高 DES 的安全性。只需在 DES 步骤之前用 64 位密钥对 64 位块进行异或运算，在 DES 步骤之后用不同的 64 位密钥进行异或运算。将有 3 个独立的密钥，两个 64 位异或密钥和 56 位 DES 密钥，总共 184 位。这种方法只比一次 DES 加密稍长一点时间。

即使第二个异或密钥可以通过查看波形来确定，这仍然比单个 DES 强得多。通过在 DES 步骤前后执行键控简单替换，可以消除波形撤销异或的危险。

### *11.2.3 快速位换位

DES 以一个位换位开始和结束。最简单的方法是一个接一个地解开这些位，把它们移动到想要的位置，或者把它们放回原位。大约在 1975 年，我和纽约约克镇 IBM 研究所的大卫·史提芬逊独立发明了一种更快的方法。我将使用一个 32 位块的转置来演示这种技术。假设以比特形式表示的明文是

![11-unnumb-2](img/11-unnumb-2.png)

其中每个拉丁或希腊字母代表一位的值，即可以是 0 也可以是 1。让我们看看如何转置，这样 a 移动到第三个位置，b 移动到第六个位置，c 移动到第九个位置，依此类推。

转置可以通过使用 4 个特殊表格来完成，每个表格有 256 个条目。每个条目是一个 32 位的块或计算机字。第一个表显示了 32 位块的第一个字节中 8 位的转置位置，如下所示:

![11-unnumb-3](img/11-unnumb-3.png)

第二个表格显示了 32 位块的第二个字节中 8 位的位置:

![11-unnumb-4](img/11-unnumb-4.png)

第三表显示了 32 位块的第三个字节中 8 位的位置:

![11-unnumb-5](img/11-unnumb-5.png)

第四个表显示了 32 位块的第四个字节中 8 位的位置:

![11-unnumb-6](img/11-unnumb-6.png)

这些点是为了让你更容易看到 32 位的位置。它们在计算机单词中代表零。现在，转置可以通过在这些特殊表中查找 4 个字节，并将 4 个结果 32 位块进行“或”运算来完成，如下所示:

![11-unnumb-7](img/11-unnumb-7.png)

这不需要移位和屏蔽。整个 32- 位换位仅使用 4 个查表和 3 个 OR 运算。这种技术的一个用途是翻转 8×8 位块。这可以使用 256 个条目的 8 个表来完成，或者只使用一个表，将位移动到每个字节 内的正确位置，如下所示:

![11-unnumb-8](img/11-unnumb-8.png)

******

### 11.2.4 短砌块

DES 和其他分组密码的一个问题是如何处理短分组。对于 DES，所有块必须正好有 8 个字符。假设你的信息有 803 个字符，100 个 8 个字符的块加上 3 个。你如何处理最后三个字符？

传统的解决方案是用空值填充最后一个块。对于纸笔加密，一些最受欢迎的技术是添加 XXXXX 或空值作为最后 5 个字符。不幸的是，这给了 Emily 5 个已知明文的字母。手动加密的一些更好的解决方案是使用一个标记，如 XX 或 JQ，然后使剩余的填充字符随机，如 XXESV，或者简单地用低频字符的任意组合填充，如 ZPGWV。解密依赖于丽娃识别真正信息结束和填充开始的能力。

在计算机中，填充必须解决两个问题。首先，丽娃必须能够判断消息在哪里结束，或者说，有多少字节的填充。第二，桑德拉想给艾米丽尽可能少为人知的明文。一些提议的方案在两个分数上都失败了。例如，一种方案建议在消息末尾填充以下内容之一:

![11-unnumb-9](img/11-unnumb-9.png)

当块大小为 32 时，这可以给 Emily 多达 31 字节的已知明文。在一般文件中，最后一个块可能是以 01 结尾的完整块，甚至是 02 02，这可能会被误认为是填充。

一个更好的解决方案是在明文文件中放置一个长度字段。这不需要是文件中的字节数，这可能需要 4 字节长度字段，它可以是最后一个块中的填充字节数。对于 DES，这是一个从 0 到 7 的数，所以只需要 3 位。长度字段可以在文件中的任何位置。最常见的位置是第一个字节、最后一个字节和最后一个块的第一个字节。填充字节本身可以随机选择。

为了避免给 Emily 甚至一个字节的已知明文，长度可以用长度指示符的低阶或高阶比特来编码，并且剩余的未使用比特可以是随机的。这使得长度指示器取 0 到 255 之间的任何值。

顺便说一句，没有法律规定你必须在文件末尾填充。如果你想在前面填充，在最后一个街区的开始，或者在第 13 个街区的中间，请便。只要桑德拉和丽娃同意，他们可以做任何他们认为最妨碍艾米丽的事情。一种可能性是分散填充字节。例如，如果文件需要 4 个填充字节，你可以把它们放在文件的第二、第四、第六和第八块的末尾，只要丽娃能知道添加了多少个填充字节。

*重叠方法* 是填充的替代方法。再次假设块大小 B 是 8，消息有 803 个字符，您将前 800 个字符加密为 100 个 8 字符的块。然后将字符 796 到 803 加密为第 101 个块。这样，消息的长度不变，但丽娃必须在破译 块 100 之前破译块 101。

## 11.3 矩阵乘法

接下来我们要看的分组密码是*高级加密标准* (AES )。但是，AES 使用一种叫做矩阵乘法的数学运算，这一点本书还没有涉及。我在介绍中承诺，我将提出每一个需要的数学概念，因此本着这种精神，我将在这里讨论矩阵乘法。这个概念在后面几章中是需要的。除非你已经很了解矩阵乘法，否则最好不要跳过这个。

一个*矩阵* 就是一个简单的被称为*标量* 元素的矩形数组。一个标量序列形成一个*向量* ，所以一个矩阵的每一行每一列都是一个向量。这些分别被称为*行向量* 和*列向量* 。m 行 n 列的矩阵称为 m×n 矩阵。如果 m = n，这个矩阵叫做*方阵* 。这里有一个 3 行 5 列的矩阵 M 的例子，叫做 3 ×5 矩阵。它有 15 个标量元素，这里用字母 a 到 o 表示

![11-unnumb-9-equation-11-1](img/11-unnumb-9-equation-11-1.png)

在这个矩阵中，3 行向量是[a，b，c，d，e]，[f，g，h，I，j]和[k，l，m，n，o]，5 列向量是[a，f，k]，[b，g，l]，[c，h，m]，[d，I，n]和[e，j，o]。矩阵的行从上到下编号，列从左到右编号。在 j 列 I 行找到的 M 的元素记为 M <sub class="fm-subscript">ij</sub> ，所以 M <sub class="fm-subscript">11</sub> 是 a，M <sub class="fm-subscript">15</sub> 是 e，M <sub class="fm-subscript">31</sub> 是 k

标量的类型包括数字，例如整数、整数模 N、有理数、实数、复数以及后面描述的其他类型。矩阵乘法对每种类型的数字都是一样的。

两个矩阵 X 和 Y 的乘积，记为 XY，是由 X 的行乘以 Y 的列形成的，我们来详细看看这是如何工作的。矩阵的行是向量，矩阵的列是向量。具有相同长度的两个向量可以乘以所谓的*内积* ，也称为*点积* ，因为向量乘法有时由 ● 点表示。该操作取一个向量的元素，将它们成对地乘以第二个向量的相应元素，然后取这些乘积的和。

假设第一个向量是[a，b，c，d]，第二个向量是[e，f，g，h]。它们有相同的长度，4 个元素，所以它们可以相乘。他们的内积是

![11-unnumb-9-equation-11-2](img/11-unnumb-9-equation-11-2.png)

设 X 和 Y 为 4×4 矩阵，设 P 为它们的乘积。即 P = XY。假设[a，b，c，d]是 X 的第 I 行，[e，f，g，h]是 y 的第 j 列。它们的乘积记为 P <sub class="fm-subscript">ij</sub> 。换句话说，第 I 行第 j 列的元素是 X 的第 I 行和 y 的第 j 列的乘积

![11-unnumb-9-equation-11-3](img/11-unnumb-9-equation-11-3.png)

类似的表达用于其他矩阵尺寸。每当 b = c 时，大小为 a×b 和 c×d 的两个矩阵可以相乘。

## 11.4 矩阵乘法

没有 ，这个重复的章节标题不是错误。数学中除了数字还有很多其他的对象可以做加法和乘法。一些例子是向量，矩阵，多项式，四元数，以及更一般的，环的元素。你甚至可以有矩阵的向量，多项式的矩阵，等等。在 15.6 到 15.8 节中有更多关于环的内容。矩阵乘法可以基于这些类型的元素及其乘法和加法规则。过程是一样的。取 X 的第 I 行与 Y 的第 j 行的内积，得到乘积矩阵的第 I 行第 j 列的元素。

矩阵乘法是不可交换的，意思是当你把一个给定的方阵 X 乘以左边或右边的第二个方阵 A 时，你通常会得到不同的结果。AX≦XA。这些被称为 X 与 a 的左乘和右乘 的

 *对于 AES，我们关注多项式的乘法和加法。高中代数我们都学过多项式的加法和乘法。从事科学和工程职业的人可能还记得这是怎么做到的。多项式也可以整除。这种除法可以留下余数，所以多项式的模数和整数的模数是一样的。(如果您想回顾这一点，请参考第 3.6 节。)

AES 中使用的标量乘法不是整数乘法，而是对另一个多项式取模的多项式乘法。这大概是本书所能达到的深度，本书针对的是一般的 读者。

## 11.5 高级加密标准(AES)

*高级加密标准*是 2001 年取代 DES 的更新的分组密码。它最初被称为 *Rijndael* ，以其发明者比利时密码学家文森特·里门和琼·代蒙命名。AES 最初以 128 位或 256 位块与 128 位、192 位或 256 位密钥的五种组合形式出现。然而，国家标准与技术研究所 (NIST)确定了该标准的 128 位块大小。轮数取决于密钥大小:128 位密钥 10 轮，192 位密钥 12 轮，256 位密钥 14 轮。

每轮使用一个轮密钥，由根据*密钥表* 从全密钥中选择的 128 位组成。在第一轮之前，执行初步操作 AddRoundKey，该操作简单地将该块与轮密钥进行异或运算。接下来的 9、11 或 13 轮中的每一轮都由 4 个操作组成，子字节、移位行、混合列和 AddRoundKey。最后一轮没有混合列步骤。

128 位块被视为一个 4×4 字节矩阵，称为*列主顺序* ，简单地说就是字节沿列而不是跨行写入矩阵，如下所示:

![11-unnumb-9-equation-11-4](img/11-unnumb-9-equation-11-4.png)

每一轮的第一步是亚字节。这是对每个字节单独执行的固定简单替换。替代被设计成高度非线性的。第 12.3.1 节详细讨论了线性特性。

下一步是 ShiftRows。这是一种转置，其中矩阵的行分别向左循环 0、1、2 和 3 个位置，如下所示:

![11-unnumb-9-equation-11-5](img/11-unnumb-9-equation-11-5.png)

每一轮的第三步，混合列，是矩阵乘法。这不是 11.3 节中描述的普通整数矩阵乘法。矩阵中的元素被视为多项式的系数。标量加法和乘法运算是对另一个多项式取模的多项式运算。这一切都是精心设计的，因此操作可以在硬件中快速执行。上一轮省略了 MixColumns。

每一轮的最后一步是 AddRoundKey。这只是块与由密钥表确定的密钥的一部分的按位异或。

我觉得这种排他性——或者说结尾非常可疑。几位电气工程师告诉我，00 和 11 的异或运算产生的波形不同于 01 和 10 的异或运算产生的波形，因此窃听者可以分辨出这两位是什么。这潜在地向窃听者揭示了密钥的 128 位。在进行高安全性加密时，我尽可能避免使用异或。

当我被迫在加密结束时使用异或运算时，例如当我实现一个标准化算法时，我会确保将密文的每一位反转偶数次。我保留了两个随机的位串 R1 和 R2，大小与块相同，它们的异或 R3 = R1 ⊕ R2。然后我先与 R1 异或密文，然后与 R2 异或，最后与 R3 异或。这将使位串恢复到其原始值，有望消除指示性波形 。

或者，你可以使用替换，而不是异或，来反转块中的所有位。你这样做两次，所以你用两个替换步骤来代替三个异或。如果你正在使用 AES，我强烈推荐增加这个额外的最后的 步骤。

## 11.6 固定与键控替代

早期 在这本书里，所有的替换都使用了混合使用关键字或数字键的字母。本章中的密码 DES 和 AES 使用可嵌入硬件 S 盒的固定替代。哪个更好？哪个更强？

当你使用固定替换时，你可以使用复杂的数学来设计一个可以抵抗多种攻击的替换。例如，如果一些输出位与一些输入位有很强的相关性，那就让 Emily 对密码使用统计攻击，比如我在 8.2 节中对杰弗逊转轮密码使用的攻击。

不幸的是，固定换人是艾米丽的活靶子。她可以研究几个月或几年的替代，并可能找到设计者遗漏的弱点。精心制作的替换往往具有数学规律性。替代被表示为特定的数学函数。这本身就是一个弱点，因为它给了 Emily 一个模拟你的密码的捷径。

我的偏好是使用一个由密钥决定的替换，该密钥可以针对每条消息进行更改。键控替换的每个实例可能比固定替换弱，但是 Emily 不能利用这样的弱点，因为她没有用于研究的替换表。如果 Emily 设法获得明文，也许是通过间谍活动，她可能能够恢复替换并了解它的弱点，但那时为时已晚。知道弱点的唯一价值是解密消息并获得明文。如果 Emily 已经有了明文，那么密钥就不再有价值了。这样的弱点不会帮助她破译下一条消息，因为那条消息会有不同的密钥，因此会有不同的弱点，如果有的话。

任何其他替换的例子，当字母表由相同的方法混合但使用不同的键时，可能没有相同的弱点。它可能具有相同类型的弱点，例如块的一些比特和/或密钥的比特与输出的一些比特之间的相关性，但是这些比特对于每个实例是不同的。

使用固定 S 盒的一个理由是，它允许加密硬件的同步操作，其中一个消息跟在另一个消息后面，中间没有间隙。使用混合字母可能需要在字母混杂时暂停。使用混合字母表需要设置。如果可以并行混合字母表，则可以消除或至少减少停顿。也就是说，当前消息被加密或解密时，下一个消息的字母表可以被混合。或者，让用户混合字母，并将混合字母作为长键 的一部分。

如果需要同步操作，并且并行混合字母是不可行的，那么回退技术是在 DES 或 AEST3】步骤之前和之后，对具有与块相同大小的密钥的块进行异或运算。我视情况将这个方法称为 *XDESX* 或 *XAESX* 。这些异或运算速度极快，并在安全性方面提供了显著的提升。总密钥大小为 184 位，比 3DES 大 16 位。我建议将最终输出反转两次，以屏蔽 波形。

## 11.7 对合密码

*对合密码是“一个密码是它自己的逆”的一种花哨说法换句话说，加密等同于解密。如果你用一个对合密码加密两次(用同一个密钥)，你会得到原始的明文。这也叫*自反* 或*自反* 。我们已经看到了一些对合密码。用二进制密钥对明文进行异或运算是对合运算(3.3 节)。Bazeries 型密码(4 . 6 . 1 节)中的分段反转换位 是对合的。翻转一个方阵，也就是把字符从左到右写入一个正方形网格，从上到下读出，这就是对合。这里是一个 3×3 的翻转矩阵的例子:*

 *![11-unnumb-10](img/11-unnumb-10.png)

数学家称这种操作为*转置* 矩阵。由于换位在密码学中有不同的含义，我就把这个*翻转* 称为矩阵。第 11.2.3 节描述了一种快速翻转矩阵的方法。

如果你在硬件中构建密码，使用对合密码可以降低成本，简化操作。你的密码机不需要有单独的加密和解密模式。

让我们看看如何构造一些类型的对合密码。

### 11.7.1 对合替代

在 一个对合替换中，如果一个字母 X 变成了一个 Y，那么 Y 必然也变成了 X，这意味着这些字母必须成对出现。要构造对合替换，首先列出所有的字母或字符。选择任意一个字母，然后选择它的配对。把这些从单子上划掉。然后选择另一个字母及其配对。把那些从单子上划掉。继续这样做，直到大部分字母配对成功。任何剩下的字母都是它们自己的反义词。与 SkipMix(第 5.2 节)一样，可以使用数字键选择连续的字母。

一个对合替换可以方便地用两行来表示。最上面一行的字母得到正下方的替代，最下面一行的字母得到正上方的替代。这是一个使用关键字 WORDGAME 和 TULIP 形成的例子。在这个例子中，R 会变成 L，L 会变成 R。

![11-unnumb-11](img/11-unnumb-11.png)

换句话说，这个对合替换的关键是这个 2 行数组。

没有必要每个字母都与不同的字母配对。几个字母可以通过替换保持不变。这些被称为*不变量* 或*固定点* 。

一个对合二元组替换可以用同样的 方法构造。

### 11.7.2 退化多字母替换

要构造一个对合的多字母密码，只需把表格的每一行都变成对合的 代换。

### 11.7.3 对合转位

对合 如果消息被分解成固定大小的块，那么换位最容易 构造。让我们假设。称固定的块大小为 b。如果对于从位置 X 移动到位置 Y 的每个字母，位置 Y 中的字母移动到位置 X，则转置是对合的。换句话说，转置将由字母的成对交换组成。

要构造对合换位，先把 1 到 B 的数写成一个列表。从列表中选择任意 2 个数字。它们是第一对互换的位置。从列表中删除这两个数字，并从列表中选择另一对数字。这是第二双。从列表中删除它们。继续这样做，直到列表最多剩下 1 个数字。如果你选择在你的换位中有一些固定点，只要早点停止配对就行了。另一种创建固定点数的方法是从列表中一次随机选择 2 个数字。如果这两个数相同，那就成了一个固定点。

表示一般转置密码的一种方式是列出块中的所有位置，并在它们下面显示它们的新位置。举个例子，

![11-unnumb-12](img/11-unnumb-12.png)

这是计算机使用的最佳格式。当一个人进行换位时，可能更方便的做法是将它折叠成半幅，如下所示:

![11-unnumb-13](img/11-unnumb-13.png)

这是同样的换位，但用了一半的空间。任何一种形式都可以用作变调的键。在这两种情况下，第一个位置的字母移动到第 13 位，而第 13 个位置的字母移动到第一个位置，第二个位置的字母移动到第七个位置，而第七个位置的字母移动到第二个位置，等等 等等。

### *11.7.4 对合分组密码

现在 我们已经知道了如何构造对合替换和转置，我们准备将这些元素组合在一起，构成对合分组密码。

在这一点上，引入更多的符号会有所帮助。设 M 是任何消息，或者是明文，或者是密文。我们将对该消息应用密码 C 表示为 CM。如果 D 是另一个密码，那么将 D 应用于文本 CM 将被表示为 DCM。这种符号看起来有点奇怪，因为 DCM 意味着先应用 C，再应用 D，但它工作得很好。你可以把 DCM 想成 D(C(M))的简写。

DC 则是先用 C 再用 D 加密形成的密码，这种新的密码称为 D 和 C 的*合成* ，合成是将两种密码组合起来形成一种新密码的运算。(有些作者称之为密码 C 和 D 的*乘积* ，并将其表示为 C♀D。)

例如，Bazeries type 4 (第 4.6.1 节)将替换与换位结合起来。合成有一个对形成对合密码很重要的数学性质:合成是结合的。这意味着如果 A，B，C 是密码，那么(AB)C = A(BC)。由于这一特性，多个密码的组合可以不用括号写成，像 ABC 甚至 ABCDEFGH。可以在这样的组合中插入括号，而不会改变结果。例如，ABCDEFGH 可以写成一个((BC)(DE))F(GH)。

让我代表*身份密码* ，将每一个明文转换成自身的密码。也就是说，对于任何消息 M，IM = M。设 C 是任何密码。用 C’表示它的倒数。(C 必须有一个反转，否则消息不能被读取。)则 CC' = C'C = I .当 C = C '时，密码 C 是对合的。

设 T 是对合密码，C 是任意密码。那么密码 CTC’就是对合密码。这是因为

![11-unnumb-13-equation-11-6](img/11-unnumb-13-equation-11-6.png)

同样，如果 A 和 B 是任意密码，那么 BCTC‘B’和 ABCTC‘B’A’是对合密码，以此类推 等等。

### 11.7.5 例，聚三次翻转

让我们 来看一个对合分组密码的例子，我称之为*聚三翻转* 。该密码对 64 位块进行运算，其形式为 ABCTC'B'A '，其中 A 和 C 是通用多字母密码，B 是对 64 位进行的列转置运算，T 是翻转 64 位方阵。

密码 A 和 C 是周期为 8 的多字母密码。也就是说，有一个单独的字母表用于加密块的每一行。每个密码的表将有 8 行，按顺序使用。没有用于选择表格行的键。相反，这 8 个键用于混合 8 个字母。A 和 C 总共需要 16 个不同的密钥，每个密钥可能是一个数字序列，用于 SkipMix 算法(5.2 节)。我建议这 16 个键每个包含 3 到 8 个数字，每个数字的范围是 0 到 255。

密码 B 是一个列转置 把 64 位的块当作一个 4×16 的网格，所以有 16 个！柱子的可能排列。64 位从左到右写入网格的各个行，然后从上到下读出各个列。列的顺序由关键字或关键短语或等效的 16 位数字字符串决定。

聚三翻是 额定 十。 ******

## 11.8 可变长度替换

分组密码可以使用固定长度或可变长度的替换来构建。 *VLA* 和 *VLB* 是使用可变长度替换的分组密码的例子。VLA 和 VLB 分组 密码都使用 128 位分组，被视为 4 行，每行 32 位。想法是在行中使用可变长度替换，然后通过在列中执行 4 位替换来混合块。每个密码的密钥是用于混合标签集和 4 位替换的密钥。

VLA 和 VLB 使用等长 Post 标签替换，如 10.5.1 节所述。因此，4 位标签被 4 位替代物替换，5 位标签被 5 位替代物替换，等等。这样，块中的每一行都保持恒定的 32 位长度。每次替换后，新标签被移动到它所在行的末尾，该行被左移以保持在 4 字节的边界上。标签应该具有至少 6 位的平均长度。

VLA 是更简单的版本。在每一轮中，首先对该行最左边(高位)的位进行 4 位替换。然后，用 shift 对每一行执行一次 Post 标记替换。如此重复 32 轮。整个加密使用了 128 个变长替换和 32 个定长 4 位替换。这个密码被定为八级。

当平均标签长度为 6 位时，我建议 VLB 应该有 4 轮，每轮第 1 行有 6 个替换步骤，第 2 行有 7 个替换步骤，第 3 行有 8 个替换步骤，第 4 行有 9 个替换步骤。

应在第 1、2 和 3 轮后进行垂直替换。为了提高速度，没有必要在每一轮的每一列中进行列替换。一个合理的选择是在每第三列中替换，例如在第 1、4、7 列中，...在第一轮之后，在第 2、5、8 栏中，...，32，在第 2 轮之后，在第 3，6，9 栏中，...，第三轮后 30。

VLB 被评为 10 级，可能是这一等级中最快的密码。它需要 120 个变长替换，带移位，32 个垂直 4 位替换，所以比 VLA 略快。

## 11.9 波纹密码

*波纹*密码 ，也称为*回绕*密码或*端绕*密码，是基于与本章前面的密码完全不同的原理的分组密码。基本思想是，块中的每个 8 位字符被用作密钥来加密其右边的下一个字符。这反过来用于加密下一个字符，以此类推，沿着块的长度向下波动，并在末尾环绕。也就是说，块中的最后一个字符被用作加密第一个字符的密钥。波纹密码最适合软件实现，因为它们很少提供并行操作的机会。

波纹密码有很多种。它们可以具有从 2 开始的任何嵌段长度，并且嵌段长度可以周期性地或随机地变化。我建议最小块长度为 5 个字符，但是您可能更喜欢从 8 个字符开始。例如，您可以使用链式数字生成器来选择块长度。当生成器生成数字 D 时，您可以使下一个块的长度为 D+5，或者 D+8，甚至 20-D。

区块可能重叠。例如，您可以使用固定的块长度 8，块从位置 1、6、11、16 开始，...每 5 个字符。最后一个块可以绕到消息的开始。当消息长度为 20 时，最后一个块可以由字符 16、17、18、19、20、1、2、3 组成。

波纹密码是纯粹的替代密码；它们根本不涉及换位。ripple 密码最简单的形式是将每个连续字符与下一个字符进行异或运算，因此 x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> 被 x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-1</sub>T6】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>代替。然后 x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n+1</sub> 被 x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>t14】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n+1</sub>代替，以此类推，贯穿整个块。

使用前一个字符加密下一个字符有很多种方法。下面是部分列表。这里 A、B 和 C 是简单的替换密码，P 是一般的多字母密码。 A(x)、B(x)和 C(x)分别代表用 A、B 和 C 加密的字符 x，P(k，x)代表用 P 加密的字符 x，使用密钥 k 选择 tableau 中的行。

<colgroup class="calibre15"><col class="calibre16" span="1" width="20%"> <col class="calibre16" span="1" width="30%"> <col class="calibre16" span="1" width="50%"></colgroup> 
| **异或** | 异或 | x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n</sub> 替换为 x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n-1</sub>t5】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n</sub>。 |
| **异曲同工** | 替代和异或 | 有三种变型，x <sub class="fm-subscript1">n</sub> 可能会被 a(x<sub class="fm-subscript1">n-1</sub>)⊕x<sub class="fm-subscript1">n</sub>，或者 x<sub class="fm-subscript1">n-1</sub>⊕b(x<sub class="fm-subscript1">n</sub>)或者 a(x<sub class="fm-subscript1">n-1</sub>)⊕b(x<sub class="fm-subscript1">n</sub>)。 |
| **异构体** | 异或和替代 | x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n</sub> 替换为 a(x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n-1</sub>t5】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n</sub>)。 |
| **添加** | 添加 | x <sub class="fm-subscript1">n</sub> 替换为 x <sub class="fm-subscript1">n-1</sub> +x <sub class="fm-subscript1">n</sub> 。一如既往，加法是模 256。 |
| **项** | 乘加，也叫**线性替换** | x <sub class="fm-subscript1">n</sub> 替换为 px <sub class="fm-subscript1">n-1</sub> +x <sub class="fm-subscript1">n</sub> ，或者 x <sub class="fm-subscript1">n-1</sub> +qx <sub class="fm-subscript1">n</sub> ，或者 px <sub class="fm-subscript1">n-1</sub> +qx <sub class="fm-subscript1">n</sub> ，其中 p 可以是任意整数，q 可以是任意奇整数。(如果你使用的字母大小不是 256，q 必须与字母大小互质。) |
| **【sadd】** | 替换和添加 | x <sub class="fm-subscript1">n</sub> 换成 A(x <sub class="fm-subscript1">n-1</sub> )+x <sub class="fm-subscript1">n</sub> ，或者 x <sub class="fm-subscript1">n-1</sub> +B(x <sub class="fm-subscript1">n</sub> )或者 A(x<sub class="fm-subscript1">n-1</sub>)+B(x<sub class="fm-subscript1">n</sub>)。 |
| **添加** | 添加和替换 | x <sub class="fm-subscript1">n</sub> 换成 A(x <sub class="fm-subscript1">n-1</sub> +x <sub class="fm-subscript1">n</sub> )。 |
| **聚** | 一般多字母替换 | x <sub class="fm-subscript1">n</sub> 换成 P(x <sub class="fm-subscript1">n-1</sub> ，x <sub class="fm-subscript1">n</sub> )。 |

由于 **xor** 或 **sxor** 可能会泄漏关于其操作数的信息，我建议使用**xor**来代替，这样在异或之后就可以进行简单的替换来屏蔽波形，即 a(x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-1</sub>T9】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>)。

注意**马德**只是**萨德**的一个特例。即 px <sub class="fm-subscript">n-1</sub> 只是 A(x <sub class="fm-subscript">n-1</sub> )的特定选择。 **madd** 的优势在于它不需要一个初步的设置阶段来混合替换字母表。同理，注意 P(A(x <sub class="fm-subscript">n-1</sub> )，B(x <sub class="fm-subscript">n</sub> ))只是简单地置换 tableau 的行和列，所以它等价于 P(x <sub class="fm-subscript">n-1</sub> ，x <sub class="fm-subscript">n</sub> )，只是使用了不同的 tableau。

这些 ripple 方法中最强的是 **poly** ，其中前面的字符 x <sub class="fm-subscript">n-1</sub> 被用作选择 tableau 中用于加密 x <sub class="fm-subscript">n</sub> 的行的键。我把这个方法叫做*键波纹* 。这将需要一个 256×256 字节的表。如果这个值太大，在将 x <sub class="fm-subscript">n-1</sub> 用作键之前，可以通过对 x <sub class="fm-subscript">n-1</sub> 应用*缩减替换* 来将 x<sub class="fm-subscript">n-1</sub>缩减到较小的范围。例如，x 可以减少到 x 模 16，或者减少到(13x+5)模 32。合适的缩减范围是 0 到 15、0 到 31 和 0 到 63。如果 R 是归约替换，P 是多字母替换，那么 x <sub class="fm-subscript">n</sub> 将被 Q(R(x <sub class="fm-subscript">n-1</sub> ，x <sub class="fm-subscript">n</sub> )替换，其中 Q 是多字母密码，具有由 P 的表格的顶部 16、32 或 64 行组成的归约表格。

如果你不能使用多字母密码，也许是因为即使是简化的表格也会占用太多的空间，或者是因为设置时间太长，那么下一个最好的选择就是使用 3 个简单的替换。用 A(B(x <sub class="fm-subscript">n-1</sub> )+C(x <sub class="fm-subscript">n</sub> ))或 a(b(x<sub class="fm-subscript">n-1</sub>)⊕c(x<sub class="fm-subscript">n</sub>))代替 x <sub class="fm-subscript">n</sub> 。这叫做*时空权衡* 。3 个简单的替换可能比单个多字母替换花费的时间稍长，但是它们将所需的空间从 65，536 字节减少到 768 字节，减少了 98.8%。

波纹密码并不局限于只使用前面的字符来加密当前字符。如果你愿意，你可以返回几个字符，例如用 a(x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-I</sub>t5】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>代替 x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> ，其中 I 可以是小于块大小的任何值。也可以使用一个以上的先前字符，例如 x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-2</sub>+x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-1</sub>+x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>，或者更一般地，x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-j</sub>+x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-k</sub>+x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>。使用一般的多字母替换法，x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> 可以被 p(x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-4</sub>T25】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-2</sub>，x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> )或者 P(x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-5</sub> ，P(x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-1</sub> ，x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> )或者其他无限的组合代替。

正如我提到的，可以使用任何大小的块。只要每个字符至少被替换一次，替换可以从块中的任何字符开始，也可以在块中的任何字符结束。如果你愿意的话，你可以绕着这个块走几圈，从最后一个字符绕到第一个字符。甚至可以重叠两个以上的块，或者使一个块完全位于另一个块或一组块内。块大小、块内的起始位置、要替换的字符数量以及与前一个和/或后一个块的重叠可以是固定的，可以定期变化，也可以随机产生。

波纹密码还可以更进一步。一条信息可以用几轮波纹密码加密。在每一轮中，信息可以被分成不同大小的块，这样块的边界就很少或从不排列，加密在块的不同点开始和结束。这就产生了马赛克甚至万花筒的效果。

波纹密码的变体太多了，无法一一列举。这些密码的等级从 4 到 10 不等。这里有几个例子。简单的 **xor** ripple 使用固定大小的块，从块的第一个字节开始到最后一个字节结束进行两轮替换，并且仅使用前一个字节作为替换密钥，被评为 4 级。一个 **sadd** ripple 密码使用不同大小的块，从块中的可变位置开始，进行至少 3 轮替换，在可变位置结束，并使用前面的字节作为替换密钥，被评为 7。一种 **poly** ripple 密码 使用不同大小的块，从块中的可变位置开始，进行至少 3 轮替换，在可变位置结束，并使用前面的字节加上一个另外的字节，该字节随着块的不同而变化，因为替换密钥被评定为 10。镶嵌方法比单层 方法强。

## 11.10 区块链

分组链是增强任何分组密码的有价值的工具。区块 链接是指使用每个区块来帮助加密下一个区块。实际上，链接是一种连锁密码，对块而不是对单个字符进行操作。从第 N 块结转到第 N+1 块的一组字节称为*链向量*T5。由于消息中的第一个块没有前身，大多数链接方案使用一个*初始化向量* (IV )来加密第一个块，就好像它是来自某个假想的前身块的链向量一样。初始化向量可以从加密密钥中导出，或者可以被视为加密的附加密钥。

抛开比特币和其他加密货币使用的区块链是密码学中使用的区块链的一种特殊形式。这是他们得到这个想法的地方。

![11-unnumb-14](img/11-unnumb-14.png)

最常见的链接形式是将链向量与下一个块逐字符组合。组合字符最常用的方法是异或。然而，可以使用第 11.8 节中描述的任何组合方法。这通常在四种模式 中的一种模式下完成。

<colgroup class="calibre15"><col class="calibre16" span="1" width="30%"> <col class="calibre16" span="1" width="70%"></colgroup> 
| 

**模式**

 | 

**描述**

 |
| **PP** | 在加密块 N+1 之前，块 N 的明文与块 N+1 的明文组合。 |
| **【PC】** | 对第 N+1 块加密后，第 N 块的明文与第 N+1 块的密文合并。 |
| **【CP】** | 在加密块 N+1 之前，块 N 的密文与块 N+1 的明文组合。 |
| **CC**T5】 | 对第 N+1 块加密后，将第 N 块的密文与第 N+1 块的密文合并。 |

为了获得最大的强度，链接操作应该是累积的。首先，来自块 N-1 的链向量与块 N 组合。该结果成为新的链向量，其与块 N+1 组合。链式 **PP** 最强，链式 **PC** 次之。模式 **CP** 和 **CC** 要弱很多，因为艾米莉可以看到链向量。我建议模式 **CP** 和 **CC** 只能与组合功能**xor**、**相加** 和 **poly** 一起使用。

虽然模式 **CC** 和 **CP** 较弱，但使用它们还是有优势的。在模式 **CC** 和 **CP** 中，不需要单独的初始化向量。Sandra 可以使用明文消息的最后一个块作为初始化向量。丽娃可以先简单地破译最后一块。事实上，丽娃可以破译任何块，而不需要先破译块。如果密码使用指示器，这可能是有价值的(第 14.3 节)。丽娃将首先破译指示块。

让我们来看看一些更强的链接块的方法。

### 11.10.1 多字母链

异或 是将 block N 与 block N+1 结合的一种弱方式。更好的方法是 **xors** ，即首先使用异或，然后对结果字符使用简单的替换。比这好得多的是使用一种通用的多字母密码。使用链向量中的每个字符作为密钥来选择 tableau 中的行，以加密块 N+1 中的相应字符。可以使用 4 种链接模式中的任何一种。模式 PP 是 最强。

### 11.10.2 加密链接

链接的标准模式使用块 N 的明文或密文作为链接向量，没有修改。对链向量应用某种加密要强得多。这可以是基本的，例如简单的替换或分段反转(第 4.6 节)。如果每个块的替换或换位不同，那么这种简单的方法可能是有效的。一个键波纹 非常适合这个目的(第 11.8 节)。用于链向量的加密应该有它自己的独立密钥。如果链向量被更强地加密，模式**CC**T8】和 **CP** 将不再是 弱。

### 滞后链接

链接 不限于前面的块。链接也可以利用更早的块。块 N 可以与块 N-1 组合，或者与多个先前的块组合，例如块 N-1 和块 N-j。如果 i > j，这需要 i 块的初始化向量。

类似地，链向量可以跨越几个先前的块。例如，链向量可以来自块 N-2 的后一半和块 N-1 的前一半。

### 11.10.4 室内水龙头

一个 使用明文或密文作为链向量的弱点在于，这些都是或者可能会成为艾米莉所知的。一种解决方案是加密链向量，如第 11.10.2 节所述。第二种解决方案是从块加密的某个中间回合中获取链向量。这叫做*龙头* 。例如，如果分组密码有 10 轮，您可以使用第 5 轮的输出作为链向量。在开始加密下一个块之前，将这个链向量与下一个块的明文相结合。这是模式 **IP** 。

这可以更进一步。您可以使用多个 tap，它们可以在多个地方与下面的块结合，或者与明文结合，或者与密文结合，或者在各轮加密之间结合。每次点击都会产生一个单独的链向量，因此对于 N 次点击，您必须有 N 个初始化向量。任何或所有这些链向量都可以加密。链向量可以使用相同的密钥加密，或者每个链向量可以有自己独立的密钥。波纹密码(第 11.8 节)非常适合于加密链 向量。

### 密钥链

通常情况下 ，链接是在每个块的文本上完成的。但是，也可以使用键链接。假设您有一个分组密码，其中每个分组使用相同的密钥 K。通过对每个块使用不同的密钥，可以大大增强该密码。实现这一点的一种方法是通过链接。你用 K 作为密钥加密第一个块。(初始化向量对于密钥链是可选的。)然后你就可以用 K ● P <sub class="fm-subscript">1</sub> ，K ● C <sub class="fm-subscript">1</sub> 或者 K ● I <sub class="fm-subscript">1</sub> 为密钥对第二个块进行加密，其中 ● 代表组合函数中的一个，比如 **xors** 或者**add**逐字节执行。同样，您使用 K ● P <sub class="fm-subscript">2</sub> ，K ● C <sub class="fm-subscript">2</sub> 或 K ● I <sub class="fm-subscript">2</sub> 作为密钥对第三个块进行加密，依此类推。这给了你三种新的链接模式， **PK** ， **CK** 和 **IK** 。可以同时使用键链接和块链接，比如说 **PK** 和 **IP** 。这是一个极其强大的 组合。

### 11.10.6 链接模式总结

总共有 12 种可能的链接模式。链接向量可以取自三个来源中的任何一个:明文、内部阶段或当前块的密文。链接向量可以与以下四个目标中的任何一个结合:密钥、明文、内部阶段或下一个块的密文。

除了这些选择之外，链向量可以每次取新的，或者它可以与来自前一个块的链向量相结合。链向量可以原样使用，或者可以在与目标组合之前加密。链接可以在连续的块上操作，或者可以是滞后的。许许多多 o f 选项。

### 11.10.7 链接短块

当 消息中的最后一个块很短，并且你使用重叠方法(第 11.2.4 节)来处理短块时，不清楚如何链接重叠的块。解决方法是从两个街区后开始连锁。如果有 N 个块，来自块 N-2 的链向量被用于块 N-1 和块 N 的

### 11.10.8 链接可变长度块

一个 最后一个问题在我们离开块链接的话题之前，需要涉及到可变块大小。我建议链向量保持固定长度。如果消息块的长度 L 小于链向量的长度，则将链向量的前 L 个字节与消息块合并。替换链向量的 L 个字节，其余的保持不变。例如，如果链向量为 **1234567890** ，块为 **样本** ，则将 **123456** 与 **样本** 合并。如果这产生了 **ZQm"w+** ，那么块变成了 **ZQm"w+** 并且链向量变成了 **ZQm"w+7890** 。

![11-unnumb-15](img/11-unnumb-15.png)

如果链向量比消息块短，则根据需要用其自身的尽可能多的副本扩展该块的链向量。例如，如果链向量为 **123456** ，块为 **约定** ，则将 **1234561234** 与 **约定** 合并。如果这样得出 **qA & Vm！7^oS** 块变成了 **qA & Vm！7^oS** 和链向量变成了和 **qA & Vm！** 。

![11-unnumb-16](img/11-unnumb-16.png)

在两种情况下，链接后块保持相同的长度，链向量保持相同的长度。

## 11.11 加强分组密码

一旦你有了一个强大的分组密码，只需很少的额外努力就可以进一步加强。所需要的只是在应用分组密码之前对明文进行轻度加密，在完成分组密码之后对密文进行轻度加密。我称之为*三明治*技巧，额外的步骤称为*预测器*和*后置密码* 步骤。如果你觉得有点顽皮，你可以称之为*鲁宾三明治*。“轻微”是指使用简单的一轮一步密码，如简单替换或密钥变换(第 7.6 节)。例如，您可以在分组密码之前使用简单的替换,在分组密码之后使用密钥换位，反之亦然。一个更强但更快的选择是将块的前 8 个字节视为两个 32 位整数，并将每个整数乘以范围为 3 到 2 <sup class="fm-superscript">32</sup> -1 模 2 <sup class="fm-superscript">32</sup> 的奇数乘数。

由于分组密码已经很强大，这些额外步骤的主要目的是增加总密钥大小，以抵御暴力攻击和中间相遇攻击。当 precipher 和 postcipher 步骤具有独立于块密码密钥的长密钥时，这种方法效果最好。例如，如果 precipher 或 postcipher 是简单替换，它可能有一个长 SkipMix 密钥。

作为一个实际的例子，DES 使用了一个小的 56 位密钥。如果添加简单的替换 precipher 和 postcipher 步骤，每个步骤都有一个独立的 64 位混合密钥，那么总密钥大小将达到 184 位。这比 3DES 更强大，速度快了近 3 倍。

然而， DES 的设计没有任何设置阶段。precipher 可以很容易地完成没有设置。简单地与明文异或 64 位的 precipher 密钥。这将总密钥大小从 56 位增加到 120 位。仅此一点，就比 2DES 更强，更能抵抗中间人攻击。后置密码步骤有点棘手。出于前面讨论过的原因，我们希望避免在最后一步使用 exclusive-OR，并且我们也不希望设置。这可以通过使用固定的多字母密码来实现。也就是说，表格是预先选择的，并内置到设备或软件中。

一种可能性是使用 4 比特组的 16×16 表格。64 位块被视为 16 个 4 位组。每个 4 位组使用 64 位后置密码密钥的 4 位进行加密。因此，总密钥大小还是 184 位。这也比 3DES 强，而且快了将近 3 倍。

这种方法奏效的原因是 DES 本身足够强大，因此唯一可行的攻击是暴力攻击。给密钥增加额外的 128 个 T2 位使得暴力破解 T4 变得不可行。**