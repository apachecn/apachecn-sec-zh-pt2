# 7个签名和零知识证明

本章涵盖了

*   零知识证明和密码签名
*   现有的加密签名标准
*   签名的微妙行为和避免它们的陷阱

您将了解到最普遍、最强大的加密原语之一——数字签名。简而言之，数字签名类似于您所熟悉的现实生活中的签名，即您在支票和合同上书写的签名。当然，除了数字签名是加密的，因此它们比它们的笔和纸等价物提供了更多的保证。

在协议的世界里，数字签名开启了许多不同的可能性，在本书的第二部分你会一次又一次地遇到它们。在这一章中，我将介绍这个新的原语是什么，它如何在现实世界中使用，以及现代数字签名标准是什么。最后，我将谈谈安全考虑和使用数字签名的危险。

注 签名在密码学中通常被称为*数字签名*或*签名方案*。在本书中，我交替使用这些术语。

对于这一章，你需要阅读

*   第二章杂凑函数

*   第五章重点交流

*   第六章非对称加密

## 7.1什么是签名？

我在第一章中解释过，加密签名与现实生活中的签名非常相似。因此，它们通常是最容易理解的加密原语之一:

*   只有您可以使用您的签名来签署任意消息。

*   任何人都可以在邮件上验证你的签名。

由于我们在非对称加密领域，你可能会猜到这种不对称是如何发生的。一个*签名方案*通常包含三种不同的算法:

*   一种密钥对生成算法，签名者使用它来创建新的私有和公共密钥(公共密钥可以与任何人共享)。

*   一种采用私钥和消息生成签名的签名算法。

*   采用公钥、消息和签名并返回成功或错误消息的验证算法。

有时私钥也被称为*签名密钥*，而公钥被称为*验证密钥*。有道理，对吧？我在图7.1中概括了这三种算法。

![](../Images/07_01.png)

图7.1数字签名界面。像其他公钥加密算法一样，您首先需要通过一个密钥生成算法生成一个密钥对，该算法采用一个安全参数和一些随机性。然后，您可以使用带有私钥的签名算法对消息进行签名，并使用带有公钥的验证算法对消息上的签名进行验证。如果您没有访问相关私钥的权限，就不能伪造验证公钥的签名。

签名有什么用？它们适用于验证消息的来源以及消息的完整性:

*   *出处*——如果上面有我的签名，那就是我写的。

*   *完整性*—如果有人修改了消息，签名就会失效。

注意 虽然这两个属性与认证相关联，但它们通常被区分为两个独立的属性:*来源认证*和*消息认证*(或完整性)。

从某种意义上来说，签名类似于你在第3章学到的消息认证代码(MAC)。但与MAC不同，它们允许我们不对称地认证消息:参与者可以在不知道私钥或签名密钥的情况下验证消息是否被篡改。接下来，我将向您展示如何在实践中使用这些算法。

运动

正如您在第3章中看到的，MAC产生的认证标签必须在恒定时间内进行验证，以避免计时攻击。你认为我们需要为验证签名做同样的事情吗？

### 7.1.1实践中如何签名和验证签名

我们来看一个实际例子。为此，我使用了pyca/cryptography([https://cryptography . io](https://cryptography.io))，这是一个备受推崇的Python库。下面的清单只是生成一个密钥对，使用私钥部分对消息进行签名，然后使用公钥部分验证签名。

清单7.1用Python签署和验证签名

```
from cryptography.hazmat.primitives.asymmetric.ed25519 import (
    Ed25519PrivateKey                                              ❶
)

private_key = Ed25519PrivateKey.generate()                         ❷
public_key = private_key.public_key()                              ❷

message = b"example.com has the public key 0xab70..."              ❸
signature = private_key.sign(message)                              ❸

try:                                                               ❹
    public_key.verify(signature, message)                          ❹
    print("valid signature")                                       ❹
except InvalidSignature:                                           ❹
    print("invalid signature")                                     ❹
```

❶ 使用Ed25519签名算法，这是一种流行的签名方案

❷ 先生成私钥，再生成公钥

❸ 使用私钥，签署消息并获得签名

❹使用公钥，验证消息上的签名

如我之前所说，数字签名开启了现实世界中的许多用例。让我们在下一节看一个例子。

### 7.1.2签名的一个主要用例:经认证的密钥交换

第5章和第6章介绍了两个参与者之间执行密钥交换的不同方式。在相同的章节中，您了解到这些密钥交换对于协商共享秘密是有用的，共享秘密可用于通过认证的加密算法保护通信。然而，密钥交换并没有完全解决在两个参与者之间建立安全连接的问题，因为一个活跃的中间人(MITM)攻击者可以扮演密钥交换的双方。这是签名进入环的地方。

假设Alice和Bob试图在他们之间建立一个安全的通信通道，并且Bob知道Alice的验证密钥。知道了这一点，Alice就可以使用她的签名密钥来验证她在密钥交换中的身份:她生成一个密钥交换密钥对，用她的签名密钥对公钥部分进行签名，然后将密钥交换公钥与签名一起发送。Bob可以使用他已知的相关验证密钥来验证签名是否有效，然后使用密钥交换公钥来执行密钥交换。

我们称这样的密钥交换为*认证密钥交换*。如果签名无效，Bob可以知道有人正在积极地MITM密钥交换。我在图7.2中说明了认证密钥交换。

![](../Images/07_02.png)

图7.2第一幅图(上图)代表一个未经认证的密钥交换，对于一个活跃的MITM攻击者来说是不安全的，他可以通过交换他们自己的公钥来模拟交换的双方。第二张图片(底部)表示密钥交换的开始，通过Alice在她的公钥上的签名进行验证。由于Bob(他知道Alice的验证密钥)在消息被MITM攻击者篡改后无法验证签名，他中止了密钥交换。

注意，在这个例子中，密钥交换只在一方被认证:虽然Alice不能被模仿，但是Bob可以。如果双方都被认证(鲍勃会签署他的密钥交换部分)，我们称这个密钥交换为*相互认证的密钥交换*。签名密钥交换可能看起来还不是非常有用。似乎我们把事先不知道Alice的密钥交换公钥的问题移到了事先不知道她的验证密钥的问题上。下一节将介绍认证密钥交换的实际应用，这将更有意义。

### 7.1.3真实世界的使用:公钥基础设施

如果你假设信任是*可传递的*，签名会变得更加强大。我的意思是，如果你信任我，我信任爱丽丝，那么你也可以信任爱丽丝。她很酷。

信任的传递性允许你以极端的方式扩展系统中的信任。假设您对某个权威机构及其验证密钥有信心。此外，假设这个机构已经签署了消息，表明Charles的公钥是什么，David的公钥是什么，等等。然后，你可以选择对这个映射有信心！这样的映射被称为*公钥基础设施*。例如，如果您试图与Charles进行密钥交换，而他声称他的公钥是一个看起来像3848的大数字。。。，您可以通过检查您“亲爱的”权威机构是否签署了类似“Charles的公钥是3848”的消息来验证这一点。。."

这个概念的一个实际应用是 *web公钥基础设施* (web PKI)。web PKI是您的web浏览器用来验证它与您每天访问的大量网站进行的密钥交换的工具。对web PKI(如图7.3所示)的一个简单解释如下:当你下载一个浏览器时，它带有一些嵌入到程序中的验证密钥。这个验证密钥链接到一个权威机构，该机构的责任是签署成千上万个网站的公钥，这样你就可以在不知道这些公钥的情况下信任它们。你没有看到的是，这些网站必须向权威机构证明他们真正拥有自己的域名，然后才能获得公钥签名。(实际上，您的浏览器信任许多权威机构来完成这项工作，而不仅仅是一个。)

![](../Images/07_03.png)

图7.3在web PKI中，浏览器信任一个权威机构来证明一些域链接到一些公钥。当安全地访问一个网站时，您的浏览器可以通过验证权威机构的签名来验证该网站的公钥确实是他们的(而不是来自某个MITM)。

在这一部分，你从高层次的角度了解了签名。让我们更深入地了解签名是如何工作的。但为此，我们首先需要绕道而行，看一看一种叫做零知识证明(ZKP)的东西。

## 7.2零知识证明:签名的起源

要理解签名在密码学中是如何工作的，最好的方法就是理解它们来自哪里。出于这个原因，让我们花点时间简单介绍一下ZKPs，然后我将回到签名。

想象一下，佩吉想要向维克多证明什么。例如，她想证明她知道某个组元素的底数的离散对数。换句话说，她想证明她知道 *x* 给定*Y*=*g*T7】x与 *g* 某组的生成元。

![](../Images/07_03_UN01.png)

当然，最简单的解决方案是佩吉简单地发送值 *x* (称为*证人*)。这个解决方案将是一个简单的*知识证明*，这个也可以，除非Peggy不想让Victor知道。

注 从理论上来说，我们说这个协议产生的一个证明是*完成的*如果佩姬可以用它向维克多证明她认识证人的话。如果她不能用它来证明她所知道的，那么这个方案就没用了，对吗？

在密码学中，我们最感兴趣的是不会向验证者泄露证人的知识证明。这样的证明被称为*零知识证明* (ZKPs)。

### 7.2.1 Schnorr识别协议:交互式零知识证明

在接下来的几页中，我将从被破坏的协议中逐步构建一个ZKP，向你展示爱丽丝如何证明她知道 *x* 而不泄露 *x* 。

在密码学中，处理这类问题的典型方法是“隐藏”具有一定随机性的值(例如，通过加密)。但是我们做的不仅仅是隐藏:我们还想证明它就在那里。为了做到这一点，我们需要一个代数的方法来隐藏它。一个简单的解决方案是简单地给见证添加一个随机生成的值 *k* :

*s*=*k*+*x*

然后，佩吉可以将隐藏的见证人 *s* 和随机值 *k* 一起发送给维克多。此时，维克多没有理由相信佩吉确实在 *s* 中隐藏了证人。的确，如果她不知道证人 *x* ，那么 *s* 很可能只是某个随机值。维克多所知道的是，证人 *x* 隐藏在 *g* 的指数中，因为他知道*Y*=*g*<sup class="fm-superscript2">x</sup>。

为了查看佩吉是否真的认识证人，维克多可以检查她给他的信息是否与他所知道的相符，这也必须在 *g* 的指数中完成(因为证人就在这里)。换句话说，Victor检查这两个数字是否相等:

*   *g*<sup class="fm-superscript2">s</sup>(=*g*<sup class="fm-superscript1">T8】k+*x*</sup>)

*   *Y*×*g*T5】k(=*g*<sup class="fm-superscript2">x</sup>×*g*<sup class="fm-superscript2">k</sup>=*g*<sup class="fm-superscript1">*x*+*k*</sup>)

这个想法是，只有认识证人 *x* 的人才能构建一个满足这个等式的“盲”证人 *s* 。因此，这是知识的证明。我在图7.4中概括了这个ZKP系统。

![](../Images/07_04.png)

图7.4为了向Victor证明她认识一个证人 *x* ，Peggy将其隐藏(通过将其添加到一个随机值 *k* 中)并发送隐藏的证人 *s* 来代替。

没那么快。这个方案有一个问题——它显然不安全！事实上，因为隐藏证人 *x* 的等式只有一个未知数( *x* 本身)，所以维克多可以简单地反转等式来检索证人:

*x*=*s*–*k*

为了解决这个问题，佩吉可以隐藏随机值 *k* 本身！这一次，她必须将随机值隐藏在指数中(而不是将其与另一个随机值相加)，以确保维克托的方程仍然有效:

*R*=*g*T5】k

通过这种方式，Victor不知道值 *k* (这是第5章中涉及的离散对数问题)，因此，无法恢复证人 *x* 。然而，他仍然有足够的信息来验证佩吉知道 *x* ！Victor只需检查*g*<sup class="fm-superscript2">s</sup>(=*g*<sup class="fm-superscript1">*k*+*x*</sup>=*g*<sup class="fm-superscript2">k</sup>×*g*<sup class="fm-superscript2">x</sup>是否等于*Y*×*R*(=*g*我在图7.5中回顾了ZKP协议的第二次尝试。

![](../Images/07_05.png)

图7.5做一个知识证明*零知识*，证明者可以用一个随机值 *k* 隐藏见证人 *x* ，然后隐藏随机值本身。

我们的计划还有最后一个问题——佩吉可以作弊。她可以让维克多相信她认识 *x* 而不认识 *x* ！她所要做的就是颠倒她计算证明的步骤。她首先生成一个随机值 *s* ，然后根据 *s* 计算值 *R* :

*R*=*g*T5】s×*Y*<sup class="fm-superscript">–1</sup>

Victor然后计算出*Y*×*R*=*Y*×*g*T9】s×*Y*T13】–1，确实匹配 *g* <sup class="fm-superscript2">s</sup> 。(Peggy使用逆运算来计算值的技巧在密码学的许多攻击中都有使用。)

注 从理论上来说，我们说，如果佩姬无法欺骗(如果她不知道 *x* ，那么她就无法欺骗维克多)，那么这个方案就是“健全的”。

为了让ZKP协议听起来合理，Victor必须确保Peggy从 *R* 计算 *s* ，而不是逆运算。为此，Victor使协议*交互*:

1.  佩吉必须提交她的随机值 *k* ，这样她以后就不能改变它了。

2.  在得到Peggy的承诺后，Victor在协议中介绍了自己的一些随意性。他生成一个随机值 *c* (称为*挑战*)并发送给佩吉。

3.  然后，佩姬可以根据随机值 *k* 和挑战 *c* 计算她的隐藏提交。

注意 你已经在第二章中学习了提交方案，我们使用了一个散列函数来提交一个值，这个值我们以后可以公开。但是基于散列函数的承诺方案不允许我们对隐藏值进行有趣的运算。相反，我们可以简单地将生成器提高到值， *g* <sup class="fm-superscript3">k</sup> ，我们已经在做了。

因为没有维克多的挑战 *c* 佩吉无法执行最后一步，并且维克多不会在没有看到对随机值 *k* 的承诺的情况下将挑战发送给她，佩吉被迫基于 *k* 计算 *s* 。我在图7.6中说明的获得的协议通常被称为作为 *Schnorr识别协议*。

![](../Images/07_06.png)

图7.6施诺尔辨认协议是一个交互式的ZKP，它是*完全的*(佩吉可以证明她认识某个证人)*声音的*(佩吉如果不认识证人就什么也证明不了)*零知识*(维克多对证人一无所知)。

所谓的*交互式ZKP系统*遵循三步模式(承诺、挑战和证明),在文献中通常被称为*适马协议*,有时也被写成σ协议(由于希腊字母的说明性形状)。但是这和数字签名有什么关系呢？

注schn orr鉴别协议在*诚实验证者零知识* (HVZK) *模型*中起作用:如果验证者(Victor)行为不诚实，没有随机选择挑战，他们可以了解到证人的一些情况。一些更强的ZKP方案是零知识的，即使验证者是恶意的。

### 7.2.2作为非交互式零知识证明的签名

之前的交互式ZKP的问题是，嗯，它是*交互式*，而现实世界的协议通常不喜欢交互性。除非两个参与者同时在线，否则交互式协议增加了一些不可忽略的开销，因为它们需要几个消息(可能通过网络)并且增加了无限的延迟。由于这个原因，交互式zkp在应用密码术的世界中大多是缺席的。

然而，所有这些讨论并不是毫无意义的！1986年，阿莫斯·菲亚特和阿迪·萨莫尔发表了一项技术，允许人们轻松地将交互式ZKP转换成非交互式ZKP。他们引入的技巧(被称为*菲亚特-沙米尔启发式*或*菲亚特-沙米尔转换*)是让证明者自己计算挑战，以一种他们无法控制的方式。

这里有一个窍门——将挑战计算为到那时为止作为协议的一部分发送和接收的所有消息的散列(我们称之为*抄本*)。如果我们假设哈希函数给出的输出与真正的随机数没有区别(换句话说，它看起来是随机的)，那么它可以成功地模拟验证者的角色。

Schnorr更进了一步。他注意到散列中可以包含任何内容！例如，如果我们在里面包含一条消息呢？我们得到的不仅仅是我们认识某个证人 *x* 的证据，而是对一条与该证据加密关联的信息的承诺。换句话说，如果证据是正确的，那么只有知道证人(成为签名密钥)的人才能提交该消息。

*那是签名！*数字签名只是非交互式的zkp。将Fiat-Shamir变换应用于Schnorr识别协议，我们得到了 *Schnorr签名方案*，我在图7.7中说明了。

![](../Images/07_07.png)

图7.7左边的协议是之前讨论过的Schnorr识别协议，是一个交互协议。右边的协议是Schnorr签名，它是左边协议的非交互式版本(其中验证者消息被对抄本上的散列函数的调用所代替)。

概括地说，Schnorr签名本质上是两个值， *R* 和 *s* ，其中 *R* 是对某个秘密随机值的承诺(通常称为 *nonce* ，因为它需要每个签名都是唯一的)，而 *s* 是在承诺 *R* 、私钥(见证方 *x* 和消息的帮助下计算的值。接下来，让我们看看签名算法的现代标准。

## 7.3您应该使用(或不使用)的签名算法

和密码学中的其他领域一样，数字签名有很多标准，有时候很难理解用哪一个。这就是我在这里的原因！幸运的是，签名的算法类型与密钥交换的相似:有基于算术模大数的算法，如Diffie-Hellman (DH)和RSA，也有基于椭圆曲线的算法，如椭圆曲线Diffie-Hellman (ECDH)。

确保你充分理解了第五章和第六章中的算法，因为我们现在要在这些算法的基础上进行构建。有趣的是，介绍DH密钥交换的论文还提出了数字签名的概念(没有给出解决方案):

*为了开发一个能够用某种纯电子形式的通信来替代当前书面合同的系统，我们必须发现一种与书面签名具有相同属性的数字现象。任何人都必须很容易识别签名的真实性，但是除了合法的签名者之外，任何人都不可能出示签名。我们将把任何这样的技术称为单向认证。由于任何数字信号都可以被精确复制，一个真正的数字签名必须在不为人知的情况下被识别*。

Diffie和Hellman(“密码学新方向”，1976年)

一年后(1977年)，第一个签名算法(称为RSA)与RSA非对称加密算法(在第6章中有所介绍)一起推出。RSA签名是我们要学习的第一个算法。

1991年，NIST提出了*数字签名算法(DSA)* 作为避免Schnorr签名专利的尝试。由于这个原因，DSA是Schnorr签名的一个怪异变体，在没有安全证明的情况下发布(尽管到目前为止还没有发现攻击)。该算法被许多人采用，但很快被一个名为 *ECDSA* (椭圆曲线数字签名算法)的椭圆曲线版本取代，正如椭圆曲线Diffie-Hellman (ECDH)取代Diffie-Hellman (DH)一样，这得益于它更小的密钥(见第5章)。ECDSA是我将在本节中讨论的第二个签名算法。

在Schnorr签名的专利于2008年到期后，ChaCha20-Poly1305(在第4章中介绍)和X25519(在第5章中介绍)的发明者Daniel J. Bernstein引入了一个新的签名方案，称为*edd sa*(Edwards-curve数字签名算法)，基于Schnorr签名。自从EdDSA发明以来，它很快获得了广泛的应用，现在被认为是现实世界应用中数字签名的最先进技术。EdDSA是我将在本节中讨论的第三个也是最后一个签名算法。

### 7.3.1 RSA PKCS#1 v1.5:一个糟糕的标准

RSA签名目前到处都在使用，尽管它们不应该被使用(正如您将在本节中看到的，它们存在许多问题)。这是因为该算法是第一个被标准化的签名方案，而且现实世界的应用程序向更新更好的算法转移的速度很慢。因此，在您的旅程中，您很可能会遇到RSA签名，我不能不解释它们是如何工作的，以及哪些标准是被采用的。但是我想说的是，如果您理解了第6章中RSA加密的工作原理，那么这一节应该很简单，因为使用RSA签名与使用RSA加密正好相反:

*   要签名，你*用私钥(而不是公钥)加密*消息，产生一个签名(组中的随机元素)。

*   为了验证签名，你*用公钥(而不是私钥)解密*签名。如果它返回原始消息，那么签名是有效的。

注 实际上，消息在被签名之前通常被散列，因为它将占用更少的空间(RSA只能对小于其模数的消息进行签名)。结果也被解释为一个大数字，以便可以在数学运算中使用。

如果你的私钥是私钥指数 *d* ，公钥是公钥指数 *e* 和公钥模数 *N* ，你可以

*   通过计算签署消息*签名* = *消息*T5】dT7】modT9】N

*   通过计算*签名*<sup class="fm-superscript2">e</sup>mod*N*来验证签名，并检查它是否等于消息

我在图7.8中直观地说明了这一点。

![](../Images/07_08.png)

图7.8要使用RSA签名，我们只需执行RSA加密算法的逆运算:我们用私有指数对消息求幂，然后为了验证，我们用公共指数对签名求幂，公共指数返回给消息。

这是可行的，因为只有知道私有指数 *d* 的人才能在消息上生成签名。与RSA加密一样，安全性与因式分解问题的难度紧密相关。

使用RSA进行签名的标准是什么？幸运的是，它们遵循与RSA加密相同的模式:

*   在PKCS#1 v1.5文档中，用于加密的RSA被松散地标准化。同一文档包含了与RSA签名的规范(没有安全证明)。

*   RSA随后在PKCS#1 v2文档中以更好的结构被再次标准化(称为RSA-OAEP)。RSA签名也出现了同样的情况，RSA-PSS在同一文档中被标准化(带有安全证明)。

我在关于非对称加密的第6章中谈到了RSA PKCS#1 v1.5。该文档中标准化的签名方案与加密方案非常相似。要签名，首先使用您选择的哈希函数对消息进行哈希处理，然后根据PKCS#1 v1.5的签名填充(类似于同一标准中的加密填充)进行填充。接下来，用您的私有指数加密填充和散列的消息。我在图7.9中对此进行了说明。

![](../Images/07_09.png)

图7.9 RSA PKCS#1 v1.5签名。为了签名，散列然后用PKCS#1 v1.5填充方案填充消息。最后一步是用私钥 *d* 模 *N* 对填充的散列消息求幂。要进行验证，只需用公共指数 *e* 模 *N* 对签名求幂，并验证它是否与填充和哈希后的消息匹配。

众多RSA

顺便说一句，不要被围绕RSA的不同术语所迷惑。有RSA(*非对称加密原语*)和RSA(*签名原语*)。除此之外，还有RSA(该公司)，由RSA的发明者创立。当提到使用RSA加密时，大多数人会提到RSA PKCS#1 v1.5和RSA-OAEP方案。当提到使用RSA的签名时，大多数人会提到RSA PKCS#1 v1.5和RSA-PSS方案。

我知道这可能会令人困惑，尤其是对于PKCS#1 v1.5标准。虽然在PKCS#1 v1.5中有正式的名称来区分加密和签名算法(RSAES-PKCS1-v1_5用于加密，RSASSA-PKCS1-v1_5用于签名)，但我很少看到使用这些名称。

在第六章中，我提到了针对RSA PKCS#1 v1.5版加密的破坏性攻击；不幸的是，RSA PKCS # 1 1.5版签名也是如此。1998年，在Bleichenbacher发现RSA PKCS#1 v1.5对加密的毁灭性攻击后，他决定看看签名标准。Bleichenbacher在2006年带着对RSA PKCS#1 v1.5的*签名伪造*攻击回来了，这是对签名攻击的最具灾难性的类型之一——攻击者可以在不知道私钥的情况下伪造签名！与第一次攻击直接破解加密算法不同，第二次攻击是实现攻击。这意味着如果签名方案被正确实现(根据规范)，攻击就不会成功。

一个实现缺陷听起来并不像一个算法缺陷那么糟糕，也就是说，如果它很容易避免并且不会影响很多实现的话。不幸的是，2019年显示，令人尴尬的RSA PKCS#1 v1.5签名开源实现实际上落入了那个陷阱，并错误地实现了标准(参见Chau等人的“用符号执行分析语义正确性:关于PKCS#1 v1.5签名验证的案例研究”)。各种实现缺陷最终导致了Bleichenbacher伪造攻击的不同变体。

不幸的是，用于签名的RSA PKCS#1 v1.5仍然被广泛使用。如果出于向后兼容的原因，你真的*不得不*使用这个算法，请注意这些问题。话虽如此，但这并不意味着用于签名的RSA是不安全的。故事并没有到此结束。

### 7.3.2 RSA-PSS:更好的标准

RSA-PSS在更新的PKCS#1 v2.1中被标准化，并包含了一个安全证明(不同于以前的PKCS#1 v1.5中标准化的签名方案)。新的规范是这样工作的:

*   使用PSS编码算法对消息进行编码

*   使用RSA对编码的消息进行签名(如PKCS#1 v1.5标准中所做的)

PSS编码稍微复杂一些，并且类似于OAEP(最佳非对称加密填充)。我在图7.10中对此进行了说明。

![](../Images/07_10.png)

图7.10 RSA-PSS签名方案使用掩码生成函数(MGF)对消息进行编码，就像你在第6章中学习的RSA-OAEP算法一样，然后以通常的RSA方式进行签名。

验证RSA-PSS生成的签名只是在签名被提升到公共指数模公共模数时反转编码的问题。

PSS的可证明安全性

PSS(用于*概率签名方案*)是可证明安全的，这意味着没有人能够在不知道私钥的情况下伪造签名。RSA-PSS不是证明如果RSA是安全的，那么RSA-PSS是安全的，而是证明了逆命题:如果有人能破解RSA-PSS，那么有人也能破解RSA。这是密码学中常用的证明方法。当然，这只有在RSA是安全的情况下才有效，这是我们在证明中假设的。

如果你还记得的话，我在第六章中还谈到了RSA加密的第三种算法(称为RSA-KEM)，这是一种更简单的算法，没有人使用过，但也被证明是安全的。有趣的是，RSA for signatures也反映了RSA加密历史的这一部分，并且有一个几乎没人使用的简单得多的算法；它叫做*全域名哈希* (FDH)。FDH的工作方式是简单地散列一条消息，然后使用RSA对其签名(将摘要解释为一个数字)。

尽管RSA-PSS和FDH都有安全证明并且更容易正确实现，但今天大多数协议仍然使用RSA PKCS#1 v1.5进行签名。这只是另一个通常发生在不认可的加密算法周围的缓慢的例子。因为旧的实现仍然必须与新的实现一起工作，所以很难移除或替换算法。想想不更新应用程序的用户、不提供新版本软件的供应商、无法更新的硬件设备等等。接下来，我们来看一个更现代的算法。

### 7.3.3椭圆曲线数字签名算法(ECDSA)

在这一节中，我们来看看ECDSA，它是DSA的一种椭圆曲线变体，其发明目的只是为了规避Schnorr签名中的专利。许多标准中都规定了签名方案，包括NIST的FIPS 186-2、ISO 14888-3、ANSI X9.62、IEEE P1363等等。并非所有的标准都兼容，希望互操作的应用程序必须确保它们使用相同的标准。

不幸的是，和DSA一样，ECDSA没有安全证明，而Schnorr签名有。尽管如此，ECDSA已经被广泛采用，并且是最常用的签名方案之一。在这一节中，我将解释ECDSA如何工作以及如何使用它。与所有此类方案一样，公钥几乎总是根据相同的公式生成:

*   私钥是随机生成的一个大数 *x* 。

*   公钥是将 *x* 作为一个生成器(椭圆曲线密码学中称为*基点*)创建的一个组中的一个索引来获得的。

更具体地说，在ECDSA中，使用[*x**G*计算公钥，这是标量 *x* 与基点 *G* 的标量乘法。

加法还是乘法记数法？

注意，我使用了*加法符号*(在标量周围放置括号的椭圆曲线语法)，但是如果我想使用*乘法符号*，我可以编写*public _ key*=*G*<sup class="fm-superscript3">x</sup>。这些差异在实践中无关紧要。大多数情况下，不关心群的基本性质的密码协议是使用乘法符号编写的，而专门在基于椭圆曲线的群中定义的协议倾向于使用加法符号编写。

为了计算ECDSA签名，您需要与Schnorr签名相同的输入:您正在签名的消息的散列( *H* ( *m* ))、您的私钥 *x* ，以及每个签名唯一的随机数 *k* 。ECDSA签名是两个整数， *r* 和 *s* ，计算如下:

*   *r* 是*k**G*的x坐标

*   *s* 等于*k*t1(*h*(*m*)+*xr【T12 })】*

为了验证ECDSA签名，验证者需要使用相同的散列消息 *H* ( *m* )、签名者的公钥以及签名值 *r* 和 *s* 。然后验证者

1.  计算[*H*(*m*)*s*<sup class="fm-superscript">–1</sup>*G*+[*RS*<sup class="fm-superscript">–1</sup>]*public _ key*

2.  验证获得的点的x坐标与签名的值 *r* 相同

你肯定能听出和Schnorr签名有一些相似之处。随机数 *k* 有时被称为*随机数*，因为它是一个只能使用一次的数字，有时也被称为*临时密钥*，因为它必须保密。

警告我再重申一遍: *k* 决不能重复，也不可预测！如果没有这些，恢复私钥是很容易的。

一般来说，加密库在幕后执行这个nonce的生成(即 *k* 值),但有时他们不这样做，而是让调用者提供它。当然，这是一个灾难的处方。例如，在2010年，索尼的Playstation 3被发现使用带有重复nonces的ECDSA(这泄露了他们的私钥)。

警告更微妙的是，如果nonce *k* 不是均匀随机选取的(具体来说，如果你能预测前几位)，仍然存在强大的攻击，可以在短时间内恢复私钥(所谓的*格攻击*)。理论上，我们称这种密钥检索攻击为*完全破解*(因为它们破解一切！).这种完全中断在实践中非常罕见，这使得ECDSA成为一种可能以惊人的方式失败的算法。

存在避免随机数问题的尝试。例如，RFC 6979规定了一种*确定性ECDSA* 方案，即基于消息和私钥生成随机数。这意味着对相同的消息签名两次涉及相同的nonce两次，因此产生相同的签名两次(这显然不是问题)。

【ECDSA中使用的椭圆曲线与椭圆曲线Diffie-Hellman (ECDH)算法(见第5章)中流行的曲线非常相似，只有一个明显的例外: *Secp256k1* 。Secp256k1曲线在SEC 2:“推荐的椭圆曲线域参数”(【https://secg.org/sec2-v2.pdf】)中定义，由高效密码组标准(SECG)编写。由于对我在第五章提到的NIST曲线缺乏信任，比特币决定使用它而不是更流行的NIST曲线后，它获得了很大的吸引力。

Secp256k1是一种椭圆曲线，被称为 *Koblitz曲线*。Koblitz曲线只是一条椭圆曲线，其参数中有一些约束，允许实现优化曲线上的一些操作。椭圆曲线具有以下等式:

*和*<sup class="fm-superscript">【2】</sup>=*<sup class="fm-superscript">【3】</sup>+*【ax】*+*【b】**

 *其中 *a* = 0、 *b* = 7为常数， *x* 和 *y* 定义在以素数 *p* 为模的数上:

*p*= 2<sup class="fm-superscript">192</sup>–2<sup class="fm-superscript">32</sup>–2<sup class="fm-superscript">12</sup>–2<sup class="fm-superscript">8</sup>–2<sup class="fm-superscript">7</sup>–2<sup class="fm-superscript">6</sup>–2<sup class="fm-superscript">3</sup>–1

这定义了一组素数阶，就像NIST曲线一样。今天，我们有有效的公式来计算椭圆曲线上的点数。以下是素数，即Secp256k1曲线中的点数(包括无穷远点):

【例】19554 . 868686866667

我们用坐标的定点 *G* 作为生成器(或基点)

*x*= 5506626302227734366957871889516853432625064175500187360389116729240

和

y= 326705100207588169780830851305070431844712732759337482424。

尽管如此，今天ECDSA主要用于NIST曲线P-256(有时也称为*secp 256 r 1*；注意区别)。接下来让我们看看另一个广泛流行的签名方案。

### 7.3.4爱德华兹曲线数字签名算法(EdDSA)

我来介绍一下本章最后一个签名算法， *Edwards-curve数字签名算法* (EdDSA)，由Daniel J. Bernstein于2011年发表，旨在回应政府机构创造的NIST和其他曲线缺乏信任的问题。EdDSA这个名字似乎表明它是像ECDSA一样基于DSA算法，但这是骗人的。EdDSA实际上是基于Schnorr签名的，这是可能的，因为Schnorr签名的专利在2008年初就到期了。

EdDSA的一个特点是，该方案不要求每次签名操作都有新的随机性。EdDSA确定性地产生签名*。这使得该算法非常有吸引力，并且已经被许多协议和标准采用。*

 *EdDSA有望被纳入NIST即将发布的FIPS 186-5标准更新版本(截至2021年初仍为草案)。当前的官方标准是RFC 8032，它定义了两条不同安全级别的曲线，用于EdDSA。两个定义的曲线都是*扭曲的爱德华兹曲线*(一种能够实现有趣的实施优化的椭圆曲线):

*   *Edwards25519基于丹尼尔·j·伯恩斯坦(Daniel J. Bernstein)的Curve25519(已在第五章中介绍)。*它的曲线运算比Curve25519实现得更快，这要归功于椭圆曲线类型实现的优化。由于它是在Curve25519之后发明的，基于Curve25519的密钥交换X25519并没有从这些速度改进中受益。与Curve25519一样，Edwards25519提供128位安全性。

*   *Edwards448是基于迈克·汉堡的Ed448-Goldilocks曲线。*它提供224位安全。

在实践中，EdDSA大多用Edwards25519曲线实例化，组合被称为 *Ed25519* (而带有Edwards448的EdDSA被简称为Ed448)。使用EdDSA的密钥生成与其他现有方案略有不同。EdDSA不是直接生成一个签名密钥，而是生成一个秘密密钥，然后用它来导出实际的签名密钥和另一个密钥，我们称之为nonce密钥。那个临时密钥很重要！它用于确定性地生成所需的每个签名随机数。

注意 根据您使用的加密库，您可能会存储秘密密钥或两个派生密钥:签名密钥和临时密钥。这并不重要，但是如果您不知道这一点，那么如果您遇到Ed25519密钥被存储为32字节或64字节(取决于所使用的实现),您可能会感到困惑。

为了签名，EdDSA首先通过将nonce密钥与要签名的消息散列来确定性地生成nonce。此后，类似于Schnorr签名的过程如下:

1.  将随机数计算为*哈希* ( *随机数密钥* || *消息*)

2.  将承诺 *R* 计算为[*nonce*】*G*，其中 *G* 是组的基点

3.  将挑战计算为*哈希* ( *承诺* || *公钥* || *消息*)

4.  计算证明 *S* 为 *nonce* + *挑战* × *签名密钥*

署名为( *R* ， *S* )。我在图7.11中说明了EdDSA的重要部分。

![](../Images/07_11.png)

图7.11 EdDSA密钥生成产生一个秘密密钥，然后用于导出另外两个密钥。第一个导出密钥是实际的签名密钥，因此可以用于导出公钥；另一个派生密钥是nonce密钥，用于在签名操作期间确定性地派生nonce。EdDSA签名类似于Schnorr签名，除了(1)随机数从随机数密钥和消息中确定性地生成，以及(2)签名者的公钥作为质询的一部分被包括在内。

注意随机数(或临时密钥)是如何确定性地而不是概率性地从随机数密钥和给定消息中导出的。这意味着对两个不同的消息进行签名应该涉及两个不同的随机数，巧妙地防止签名者重用随机数，从而泄露密钥(ECDSA就可能发生这种情况)。对同一消息进行两次签名会产生两次相同的nonce，然后产生两次相同的签名。这显然不是问题。可以通过计算以下两个等式来验证签名:

*S**G*

*R*+*哈希* ( *R* || *公钥* || *消息*)】*公钥*

如果两个值匹配，则签名有效。这正是Schnorr签名的工作方式，除了我们现在在一个椭圆曲线组中，我在这里使用加法符号。

EdDSA最广泛使用的实例Ed25519是用Edwards25519曲线和SHA-512作为散列函数定义的。Edwards25519曲线由满足该方程的所有点定义:

–*x*<sup class="fm-superscript">【2】</sup>+*和*<sup class="fm-superscript">【2】</sup>= 1+***x***

其中值 *d* 是大数

【例】56860 . 46868668661

和变量 *x* 和 *y* 取模 *p* 大数2<sup class="fm-superscript">255</sup>–19(用于Curve25519的同一个素数)。基点是坐标的 *G*

*x*= 151122213495354007725011514095853151145401269304185720604613283949847762202

和

*y*= 4631683569492647816942839400347516314130793625256157833603165251855960。

RFC 8032实际上使用Edwards25519曲线定义了EdDSA的三种变体。所有三种变体都遵循相同的密钥生成算法，但使用不同的签名和验证算法:

*   *【ed 25519(或pured 25519)*——这是我之前解释过的算法。

*   *ed 25519 CTX*—这种算法引入了一个强制性的定制字符串，在实践中即使使用，也很少实现。唯一的区别是，每次调用散列函数时，都会添加一些用户选择的前缀。

*   *Ed25519ph(或hashed 25519)*—这允许应用程序在签署消息之前对其进行预哈希处理(因此名字中有 *ph* )。它也建立在Ed25519ctx之上，允许调用者包含一个可选的自定义字符串。

添加一个*定制字符串*在密码学中相当常见，正如你在第二章中看到的一些散列函数或者将在第八章中看到的密钥派生函数。当协议中的参与者在不同的上下文中使用相同的密钥来签署消息时，这是一个有用的补充。例如，您可以想象一个应用程序，它允许您使用您的私钥签署交易，还可以签署发给您交谈的人的私人消息。如果您错误地签署了一个看起来像是事务的消息并发送给了您邪恶的朋友Eve，如果没有办法区分您正在签署的两种类型的有效载荷，她可能会尝试将其作为有效的事务重新发布。

Ed25519ph的推出仅仅是为了满足需要签署大消息的呼叫者。正如你在第2章中看到的，散列函数通常提供一个“初始化-更新-终结”接口，允许你连续散列一个数据流，而不必将整个输入保存在内存中。

现在，您已经完成了在现实应用中使用的签名方案之旅。接下来，让我们看看在使用这些签名算法时，如何可能会搬起石头砸自己的脚。但首先，回顾一下:

*   RSA PKCS#1 v1.5仍在广泛使用，但很难正确实施，许多实施已被发现被破坏。

*   RSA-PSS具有安全性证明，更易于实现，但是由于基于椭圆曲线的更新方案，其采用率很低。

*   ECDSA是RSA PKCS#1 v1.5的主要竞争对手，主要用于NIST曲线P-256，但在Secp256k1似乎占主导地位的加密货币领域除外。

*   Ed25519基于Schnorr签名，已被广泛采用，与ECDSA相比更易于实施；对于每个签名操作，它不需要新的随机性。如果可以的话，这是你应该使用的算法。

## 7.4签名方案的微妙行为

签名方案可能表现出许多微妙的特性。虽然它们在大多数协议中可能无关紧要，但是在处理更复杂和非常规的协议时，没有意识到这些“陷阱”可能最终会使您陷入困境。本章的结尾重点关注数字签名的已知问题。

### 7.4.1签名替换攻击

*数字签名并不唯一地标识一把钥匙或一条信息*。

—安德鲁·艾耶尔(《让我们加密》中的重复签名密钥选择攻击，2015)

*替换攻击*，也被称为*重复签名密钥选择* (DSKS)，在RSA PKCS#1 v1.5和RSA-PSS上都有可能。有两种DSKS变体:

*   *密钥替换攻击*—不同的密钥对或公钥用于验证给定消息上的给定签名。

*   *消息密钥替换攻击*——不同的密钥对或公钥被用来验证一条*新*消息上的给定签名。

再来一次:第一次攻击修复消息和签名；第二个只修复签名。我在图7.12中概括了这一点。

![](../Images/07_12.png)

图7.12像RSA这样的签名算法容易受到密钥替换攻击，这对于密码学的大多数用户来说都是令人惊讶和意想不到的行为。一种*密钥替换*攻击允许一个人在一条消息上获取一个签名，并创建一个新的密钥对来验证原始签名。一种叫做*消息密钥替换*的变种允许攻击者创建一个新的密钥对和一个在原始签名下有效的新消息。

适应性选择消息攻击下的存在不可伪造性(EUF-CMA)

替换攻击是理论密码学和应用密码学之间的一个鸿沟。密码学中的签名通常用 *EUF-CMA模型*来分析，该模型代表在适应性选择消息攻击下的存在不可伪造性。在这个模型中，您生成一个密钥对，然后我请求您签署一些任意的消息。当我观察您生成的签名时，如果我能在某个时间点生成一个我以前没有请求的消息的有效签名，我就赢了。不幸的是，这个EUF-CMA模型似乎没有包含每一种边缘情况，而且像替代这样的危险微妙之处也没有被考虑在内。

### 7.4.2签名延展性

*2014年2月，曾经最大的比特币交易所MtGox关闭并申请破产，声称攻击者利用延展性攻击来耗尽其账户*。

—Christian Decker和Roger Wattenhofer(“比特币交易延展性和MtGox”，2014年)

大多数签名方案都是可延展的*:如果你给我一个有效的签名，我可以修改这个签名，使它成为一个不同的，但仍然有效的签名。我不知道签名密钥是什么，但我设法创建了一个新的有效签名。*

 *不可延展性并不一定意味着签名是独一无二的:如果我是签名者，我通常可以为同一条消息创建不同的签名，这通常没问题。一些构造，如可验证随机函数(你将在第八章后面看到)依赖于签名的唯一性，因此它们必须处理这个问题或使用具有唯一签名的签名方案(如博纳-林恩-沙查姆或BLS签名)。

强大的EUF-CMA

称为SUF-CMA(强EUF-CMA)的新安全模型试图在签名方案的安全定义中包含不可延展性(或抗延展性)。一些最近的标准，如RFC 8032，它规定了Ed25519，包括针对可延展性攻击的缓解措施。因为这些缓解措施并不总是存在或常见，所以您不应该依赖于协议中不可延展的签名。

如何处理所有这些信息？请放心，签名方案肯定不会被破坏，如果您对签名的使用不是太出格，您可能不应该担心。但是，如果您正在设计加密协议，或者如果您正在实现一个比日常加密更复杂的协议，您可能希望将这些微妙的属性隐藏起来。

## 总结

*   数字签名类似于纸笔签名，但有加密技术支持，因此任何不控制签名(私人)密钥的人都无法伪造。

*   数字签名可用于认证来源(例如，密钥交换的一方)以及提供可传递的信任(如果我信任Alice，她信任Bob，我也可以信任Bob)。

*   零知识证明(ZKPs)允许证明者证明特定信息的知识(称为见证),而不透露该信息。签名可以被视为非交互式zkp，因为它们不要求验证者在签名操作期间在线。

*   你可以使用许多标准来签名:

    *   RSA PKCS#1 v1.5目前被广泛使用，但不推荐使用，因为它很难正确实施。
    *   RSA-PSS是一个更好的签名方案，因为它更容易实现并且具有安全性证明。不幸的是，它现在并不流行，因为椭圆曲线变体支持更短的密钥，因此对网络协议更有吸引力。
    *   目前最流行的签名方案是基于椭圆曲线的:ECDSA和EdDSA。ECDSA通常与NIST曲线P-256一起使用，EdDSA通常与Edwards25519曲线一起使用(这种组合称为Ed25519)。
*   如果以非传统方式使用签名，一些微妙的属性可能会很危险:

    *   因为一些签名方案容易受到密钥替换攻击，所以总是避免关于谁签署了消息的模糊性。外部参与者可以创建新的密钥对来验证消息上已经存在的签名，或者创建新的密钥对和新的消息来验证给定的签名。
    *   不要依赖签名的唯一性。首先，在大多数签名方案中，签名者可以为同一消息创建任意数量的签名。第二，大多数签名方案是可延展的T2，这意味着外部参与者可以接受一个签名并为同一消息创建另一个有效的签名。***