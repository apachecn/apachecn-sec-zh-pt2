# 8随机性与秘密

本章涵盖了

*   什么是随机性，为什么随机性很重要
*   获得强随机性，产生秘密
*   随机性的陷阱

这是本书第一部分的最后一章，在我们进入第二部分学习现实世界中使用的实际协议之前，我还有最后一件事要告诉你。这是我迄今为止严重忽视的东西——随机性。

你一定已经注意到，在你所学的每一种加密算法中(除了哈希函数)，你都不得不在某些时候使用随机性:密钥、随机数、iv、质数、挑战等等。当我经历这些不同的概念时，随机性总是来自于一些神奇的黑盒。这并非不典型。在密码学白皮书中，随机性通常用在顶部画一个带美元符号的箭头来表示。但在某些时候，我们需要问自己这样一个问题，“这种随机性到底从何而来？”

在这一章中，我将为你提供一个答案，当提到随机性时，密码学意味着什么。我还将为您提供一些关于现实世界中加密应用程序获得随机性的实用方法。

注 对于本章，你需要阅读第二章关于散列函数和第三章关于消息认证码的内容。

## 8.1什么是随机性？

每个人都在某种程度上理解随机性的概念。无论是玩骰子，还是买彩票，我们都接触过。我第一次接触随机性是在很小的时候，当时我意识到，每当我按下计算器上的一个RAND按钮时，它都会产生一个不同的数字。这使我苦恼不已。我对电子学知之甚少，但我认为我能理解它的一些局限性。当我把4和5加在一起时，肯定会有一些电路进行计算并给出结果。但是一个随机的按钮？随机数是从哪里来的？我无法理解。

我花了一些时间去问正确的问题，并且明白计算器实际上是在作弊！他们会硬编码一大串随机数，然后一个接一个地检查。这些列表表现出很好的随机性，这意味着如果你观察你得到的随机数，1和9一样多，1和2一样多，等等。这些列表将模拟一个*均匀分布*:数字以相等的比例分布(均匀)。

当出于安全和加密目的需要随机数时，随机性必须是*不可预测的*。当然，在那个时候，没有人会把那些计算器的“随机性”用于任何与安全有关的事情。相反，加密应用程序从观察难以预测的物理现象中提取随机性。

例如，很难预测掷骰子的结果，尽管掷骰子是一个确定的过程；如果你知道所有的初始条件(你如何投掷骰子，骰子本身，空气摩擦，桌子的抓地力，等等)，你应该能够预测结果。也就是说，所有这些因素对最终结果的影响如此之大，以至于对初始条件的了解稍有不精确就会扰乱我们的预测。一个结果对其初始条件的极端敏感性被称为*混沌理论*，这也是天气等事物难以准确预测超过一定天数的原因。

下面的图片是我在一次参观位于旧金山的Cloudflare总部时拍摄的。LavaRand是一堵熔岩灯墙，这些灯产生难以预测形状的蜡。在墙前设置一个摄像头，提取图像并将其转换为随机字节。

![](../Images/08_001_UN01.png)

应用程序通常依靠操作系统来提供可用的随机性，而操作系统又根据运行它的设备类型，使用不同的技巧来收集随机性。随机性的常见来源(也称为*熵来源*)可以是硬件中断的时间(例如，你的鼠标移动)、软件中断、硬盘寻道时间等等。

熵

在信息论中，*熵*这个词用来判断一个字符串包含多少随机性。这个术语是由Claude Shannon创造的，他设计了一个熵公式，随着字符串表现出越来越多的不可预测性(从0开始表示完全可预测)，该公式将输出越来越大的数字。公式或者数字本身对我们来说并没有那么有趣，但是在密码学中，你经常会听到“这个字符串熵值低”(意味着它是可预测的)或者“这个字符串熵值高”(意味着它不太可预测)。

观察中断等事件产生的随机性不大；当设备启动时，这些事件往往是高度可预测的，它们也可能受到外部因素的恶意影响。今天，越来越多的设备可以使用额外的传感器和硬件辅助设备来提供更好的熵源。这些硬件随机数发生器通常被称为*真随机数发生器*(trng)，因为它们利用外部不可预测的物理现象，如热噪声来提取随机性。

通过所有这些不同类型的输入获得的噪声通常不“干净”,并且有时不提供足够的熵(如果有的话)。例如，从某个熵源获得的第一个比特可能经常是0，或者连续的比特可能(更有可能)相等。因此，*随机抽取器*必须清除并收集几个噪声源，然后才能用于加密应用。例如，这可以通过将散列函数应用于不同的源并将摘要异或在一起来实现。

这就是随机性的全部吗？可惜没有。从噪音中提取随机性是一个缓慢的过程。对于一些可能需要大量随机数的应用程序来说，这可能会成为一个瓶颈。下一节将描述操作系统和现实世界的应用程序如何促进随机数的生成。

## 8.2慢随机性？使用伪随机数发生器(PRNG)

到处都在使用随机性。在这一点上，你应该相信这是真的，至少对于密码学来说是这样，但是令人惊讶的是，密码学并不是唯一大量使用随机数的地方。例如，像ls这样的简单Unix程序也需要随机性！由于程序中的错误如果被利用可能是毁灭性的，二进制文件试图使用许多技巧来防御低级攻击；其中之一是 *ASLR* (地址空间布局随机化)，它在每次运行时随机化进程的内存布局，因此需要随机数。另一个例子是网络协议TCP，它在每次创建连接时使用随机数来产生不可预测的数字序列，并阻止试图劫持连接的攻击。虽然所有这些都超出了本书的范围，但了解一下在现实世界中有多少随机性最终被用于安全目的还是很有好处的。

我在上一节中暗示过，不幸的是，获得不可预测的随机性是一个缓慢的过程。这有时是由于熵源产生噪音的速度较慢。因此，操作系统通常通过使用*伪随机数发生器* (PRNGs)来优化随机数的产生。

注意 为了与不被设计为安全的随机数发生器(以及在不同类型的应用中有用的随机数发生器，如视频游戏)形成对比，prng有时被称为CSPRNGs，用于*密码安全的*prng。NIST想要以不同的方式做事(像往常一样)，经常把他们的prng*称为确定性随机位生成器*(drbg)。

PRNG需要一个初始秘密，通常称为*种子*，我们可以通过将不同的熵源混合在一起获得，然后可以快速产生大量随机数。我在图8.1中举例说明了一个PRNG。

![](../Images/08_01.png)

图8.1伪随机数发生器(PRNG)根据一个种子生成一个随机数序列。使用相同的种子使PRNG产生相同的随机数序列。使用随机输出的知识来恢复状态应该是不可能的(函数`next`是一种方法)。由此可见，仅仅通过观察产生的随机数来预测未来的随机数或恢复先前产生的随机数也是不可能的。

密码安全的PRNGs通常表现出以下特性:

*   *确定性* —两次使用相同的种子产生相同的随机数序列。这不同于我之前提到的不可预测的随机抽取:如果你知道PRNG使用的种子，PRNG应该是完全可预测的。这就是为什么这种构造被称为*伪*随机，这就是为什么PRNG可以非常快。

*   *与随机*难以区分——在实践中，你应该无法区分PRNG从一组可能的数字中输出一个随机数和一个小仙女公正地从同一组数字中选择一个随机数(假设仙女知道一种神奇的方法来挑选一个数字，这样每个可能的数字都可以以相等的概率被选中)。因此，仅凭观察产生的随机数，任何人都无法恢复PRNG的内部状态。

最后一点很重要！PRNG模拟随机均匀地挑选一个数字*，这意味着该组中的每个数字都有均等的机会被选中。例如，如果您的PRNG产生8个字节的随机数，则该集合是所有可能的8个字节的字符串，并且每个8个字节的值应该有相等的概率成为可以从您的PRNG中获得的下一个值。这包括PRNG在过去某个时候已经产生的值。*

 *此外，许多PRNGs还具有额外的安全属性。如果攻击者了解到状态(例如，在某个时间点进入你的计算机)不允许PRNG检索先前生成的随机数，那么PRNG具有*前向保密性*。我在图8.2中对此进行了说明。

![](../Images/08_02.png)

图8.2如果状态的泄露不允许恢复先前生成的随机数，则PRNG具有前向保密性。

获得PRNG的*状态*意味着您可以确定它将生成的所有未来伪随机数。为了防止这种情况，一些PRNGs具有定期自我“修复”的机制(以防出现危害)。这种修复可以通过在PRNG被播种后重新注入(或重新播种)新熵来实现。这个属性叫做*后向保密*。我在图8.3中说明了这个。

![](../Images/08_03.png)

图8.3如果一个状态的妥协不允许预测PRNG产生的未来随机数，则PRNG具有后向保密性。只有在折衷后产生新的熵并将其注入更新函数时，这种情况才会发生。

注 术语*前向*和*后向保密*经常引起混淆。如果你读到这一节，认为前向保密不应该是后向保密，后向保密应该是前向保密，那么你没有疯。由于这个原因，后向保密有时被称为未来保密，甚至是妥协后保密。

如果正确播种，PRNGs可以非常快，并且被认为是产生大量用于加密目的的随机值的安全方法。使用可预测的数字或太小的数字显然不是播种PRNG的安全方法。这实际上意味着我们有安全的加密方法来快速地将适当大小的秘密扩展到数十亿个其他秘密密钥。很酷，对吧？这就是为什么大多数(如果不是全部的话)加密应用不使用直接从噪声中提取的随机数，而是在初始步骤中使用它们来播种PRNG，然后在需要时切换到从PRNG生成随机数。

双EC借壳

今天，PRNGs大多是基于启发式的构造。这是因为基于数学难题(如离散对数)的构造太慢，不切实际。一个臭名昭著的例子是由NSA发明的依靠椭圆曲线的*双EC* 。大约在2006年，双EC PRNG被推向各种标准，包括一些NIST出版物，不久之后，几名研究人员独立地发现了算法中的一个潜在后门。这一点后来在2013年斯诺登爆料中得到证实，一年后该算法从多个标准中退出。

为了安全起见，PRNG必须播下一个*不可预知的*秘密。更准确地说，我们说PRNG随机抽取均匀采样的 *n* 字节的密钥。这意味着我们应该从所有可能的 *n* 字节字符串的集合中随机选取密钥，其中每个字节字符串都有相同的机会被选取。

在这本书里，我谈到了许多密码算法，它们产生的输出与随机输出(从随机选择的值中)无法区分。直觉上，你应该在想我们可以用这些算法来产生随机数吗？你是对的！哈希函数、xof、分组密码、流密码和MAC可用于产生随机数。哈希函数和MAC在理论上没有被定义为提供与随机无法区分的输出，但在实践中，它们经常是这样的。另一方面，像密钥交换和签名这样的非对称算法(几乎总是)与随机算法没有区别。由于这个原因，它们的输出通常在用作随机数之前被散列。

实际上，因为AES在大多数机器上都是硬件支持的，所以习惯上看到AES-CTR被用来产生随机数。对称密钥成为种子，而密文成为随机数(例如，对于0的无限字符串的加密)。在实践中，为了提供前向和后向保密，这些结构增加了一点复杂性。幸运的是，您现在已经足够理解下一节了，这一节提供了获取真实随机性的概述。

## 8.3在实践中获得随机性

您已经了解了操作系统为其程序提供加密安全随机数所需的三个要素:

*   *噪声源* —这些是操作系统从不可预测的物理现象(如设备温度或鼠标移动)中获取原始随机性的方式。

*   *清理和混合*——虽然原始的随机性可能质量很差(有些位可能会有偏差)，但操作系统会清理并混合许多来源，以便产生一个好的随机数。

*   *PRNGs* —因为的前两步很慢，所以可以使用一个单一的、均匀随机的值来播种一个可以快速产生随机数的PRNG。

在这一部分，我将解释系统如何将这三个概念捆绑在一起，为开发者提供简化的界面。操作系统公开的这些函数通常允许您通过发出系统调用来生成一个随机数。在这些系统调用的背后，实际上是一个捆绑了噪声源、混合算法和PRNG的系统(如图8.4所示)。

![](../Images/08_04.png)

图8.4在一个系统上生成随机数通常意味着熵从不同的噪声源混合在一起，并用于播种长期PRNG。

根据操作系统和可用的硬件，这三个概念可能会以不同的方式实现。2021年，Linux使用基于ChaCha20流密码的PRNG，而macOS使用基于SHA-1哈希函数的PRNG。此外，根据操作系统的不同，向开发人员公开的随机数生成器接口也会有所不同。在Windows上，`BCryptGenRandom`系统调用可以用于产生随机数，而在其他平台上，一个特殊的文件(通常称为/dev/urandom)被暴露，可以被读取以提供随机性。例如，在Linux或macOS上，可以使用`dd`命令行工具从终端读取16个字节:

```
$ dd if=/dev/urandom bs=16 count=1 2> /dev/null | xxd -p
40b1654b12320e2e0105f0b1d61e77b1
```

/dev/urandom的一个问题是，如果在设备启动后过早使用，它可能无法提供足够的熵(它的数字不够随机)。像Linux和FreeBSD这样的操作系统提供了一个叫做`getrandom`的解决方案，也就是一个系统调用，它提供了与从/dev/urandom读取几乎相同的功能。在极少数情况下，当没有足够的熵来初始化它的PRNG时，`getrandom`将阻塞程序的继续运行，并等待直到被正确播种。出于这个原因，我建议您使用`getrandom`，如果它在您的系统上可用的话。下面的清单展示了如何在C #中安全地使用`getrandom`:

清单8.1在C语言中获取随机数

```
#include <sys/random.h>

uint8_t secret[16];                                ❶
int len = getrandom(secret, sizeof(secret), 0);    ❷

if (len != sizeof(secret)) {
    abort();                                       ❸

}
```

❶ 用随机字节填充缓冲区(注意getrandom每次调用最多256字节)。

❷默认标志(0)是不阻塞的，除非正确播种。

❸ 函数可能会失败，或者返回的随机字节数少于预期值。如果是这种情况，系统已经损坏，中止可能是最好的办法。

记住这个例子，指出许多编程语言都有提供更好抽象的标准库和加密库也是有好处的。例如，可能很容易忘记`getrandom`每次调用最多只返回256字节。出于这个原因，您应该总是尝试通过您正在使用的编程语言的标准库来生成随机数。

警告 注意，很多编程语言都公开了产生可预测随机数的函数和库。这些不适合加密使用！确保你使用的随机库能够生成加密性很强的随机数。通常库的名字会有所帮助(例如，你大概能猜出你应该在Golang的`math/rand`和`crypto/rand`包之间使用哪个)，但是没有什么能代替阅读手册！

清单8.2展示了如何使用PHP 7生成一些随机字节。任何加密算法都可以使用这些随机字节。例如，作为秘密密钥来使用认证加密算法进行加密。每种编程语言做事情的方式都不一样，所以一定要查阅编程语言的文档，以便找到获得用于加密目的的随机数的标准方法。

清单8.2在PHP中获取随机数

```
<?php
$bad_random_number = rand(0, 10);    ❶

$secret_key = random_bytes(16);      ❷
?>
```

❶ 产生一个0到10之间的随机整数。虽然速度很快，但rand不能产生加密安全的随机数，因此它不适用于加密算法和协议。

❷ random_bytes用16个随机字节创建并填充一个缓冲区。该结果适用于密码算法和协议。

既然你已经知道了如何在你的程序中获得密码安全的随机性，让我们来考虑一下当你生成随机性时你需要记住的安全注意事项。

## 8.4随机性产生和安全性考虑

在这一点上，最好记住，任何基于密码学的有用协议都需要良好的随机性，而一个被破坏的PRNG可能会导致整个密码协议或算法不安全。您应该清楚MAC的安全性取决于与之一起使用的密钥，或者最轻微的可预测性通常会破坏ECDSA等签名方案。

到目前为止，这一章听起来好像产生随机性应该是应用密码学的一个简单的部分，但实际上并不是。由于各种各样的问题，随机性实际上是现实世界密码学中许多许多错误的来源:使用非加密PRNG，错误地播种PRNG(例如，使用可预测的当前时间)，等等。

一个例子包括使用*用户域prng*的程序，而不是系统调用背后的*内核prng*。用户土地规划通常会增加不必要的摩擦，如果滥用，在最坏的情况下，会破坏整个系统。OpenSSL库提供的PRNG就是一个明显的例子，该库在2006年被修补到一些操作系统中，无意中影响了所有使用易受攻击的PRNG的SSL和SSH生成的密钥。

*删除这段代码的副作用是削弱了OpenSSL PRNG的播种过程。不是混合随机数据作为初始种子，而是使用当前进程ID作为唯一的随机值。在Linux平台上，默认的最大进程ID是32，768，这导致所有PRNG操作使用的种子值非常少*。

H. D .摩尔(“Debian OpenSSL可预测的PRNG玩具”，2008年)

由于这个原因和其他原因，我将在本章后面提到，避免用户PRNG和坚持操作系统提供的随机性是明智的。在大多数情况下，坚持使用编程语言的标准库或好的加密库就足够了。

我们不能在“最佳实践”之后继续添加“最佳实践”到开发人员在编写日常代码时需要记住的东西中。

—Martin bolet(“OpenSSL PRNG(真的)不安全”，2013年)

不幸的是，再多的建议也不能让你对获得良好随机性的许多陷阱有所准备。因为随机性是每个加密算法的核心，所以犯一点小错误都会导致灾难性的后果。如果您遇到以下边缘情况，最好记住它们:

*   *分叉进程*—当使用一个PRNG用户时(一些对性能要求极高的应用程序可能别无选择)，重要的是要记住，一个分叉的程序将产生一个新的子进程，该子进程将具有与其父进程相同的PRNG状态。因此，从那时起，两个PRNGs将产生相同的随机数序列。出于这个原因，如果你真的想使用PRNG用户，你必须小心让分叉使用不同的种子。

*   *【虚拟机】*—PRNG状态的克隆在使用操作系统PRNG时也会出现问题。想想虚拟机。如果保存虚拟机的整个状态，然后从现在开始启动几次，每个实例可能会产生完全相同的随机数序列。这有时可以通过虚拟机管理程序和操作系统来解决，但在运行请求虚拟机中随机数的应用程序之前，最好先了解一下您正在使用的虚拟机管理程序在做什么。

*   *早期启动熵* —虽然由于用户与设备交互产生的噪音，操作系统应该在用户操作的设备中收集熵没有问题，但嵌入式设备和无头系统需要克服更多挑战，以便在启动时产生良好的熵。历史表明，一些设备往往以类似的方式启动，并最终从系统中积累相同的初始噪声，导致相同的种子用于其内部PRNGs，并产生相同的随机数序列。

有一个易受攻击的窗口——一个启动时熵漏洞——在此期间，Linux的灾难可能是完全可预测的，至少对于单核系统来说是这样。[.。。]当我们禁用了在无头设备或嵌入式设备上可能不可用的熵源时，Linux RNG在每次启动时都会产生相同的可预测流。

—Heninger等人(挖掘您的Ps和Qs:检测网络设备中广泛存在的弱密钥，2012年)

在这些罕见的情况下，你真的真的需要在引导早期获得随机数，你可以通过提供从另一台机器的良好播种的`getrandom`或/dev/urandom生成的一些初始熵来帮助系统。不同的操作系统可能提供这个特性，如果你发现自己处于这种情况，你应该查阅他们的手册(像往常一样)。

如果可以的话，TRNG提供了一个简单的问题解决方案。例如，现代英特尔CPU嵌入了一种特殊的硬件芯片，可以从热噪声中提取随机性。这种随机性可以通过一个叫做`RDRAND`的指令获得。

`RDRAND`论战

有趣的是，由于担心后门，英特尔的`RDRAND`一直备受争议。大多数集成了`RDRAND`作为熵源的操作系统以*贡献*的方式将其与其他熵源混合。贡献在这里意味着熵的一个来源不能强迫随机性产生的结果。

运动

想象一下，把不同来源的熵简单地异或在一起就能混合起来。你能看出这怎么可能没有帮助吗？

最后，让我提一下，避免随机性陷阱的一个解决方案是使用较少依赖随机性的算法。例如，你在第7章中看到ECDSA要求你每次签名时生成一个随机随机数，而EdDSA不要求。你在第四章看到的另一个例子是AES-GCM-SIV，如果你碰巧重复使用同一个随机数两次，它不会灾难性地崩溃，与AES-GCM相反，它会泄漏认证密钥，然后失去密文的完整性。

## 8.5公共随机性

到目前为止，我主要谈论了*私有随机性*，那种你可能需要用于你的私有密钥的。有时候，不需要隐私和*需要公开随机性*。在这一节中，我简要地调查了获得这种公共随机性的一些方法。我区分了两种情况:

*   *一对多*——你要为别人产生随机性。

*   *多对多*——一组参与者想要一起产生随机性。

首先，让我们假设你想以一种许多参与者都可以验证的方式产生一个随机流。换句话说，从你的角度来看，这种趋势应该是不可预测的，但不可能改变。现在假设您有一个基于密钥对和消息提供唯一签名的签名方案。在这样的签名方案中，存在一种称为*可验证随机函数* (VRF)的构造，以可验证的方式获得随机数(图8.5说明了这个概念)。下面显示了这是如何工作的:

1.  您生成一个密钥对并发布验证密钥。您还发布了一个公共种子。

2.  要生成随机数，您需要签署公共种子并散列签名。摘要是你的随机数，签名也是作为证明公布的。

3.  为了验证随机数，任何人都可以散列签名以检查它是否与随机数匹配，并使用公共种子和验证密钥来验证签名是否正确。

![](../Images/08_05.png)

图8.5可验证随机函数(VRF)通过公钥加密产生可验证的随机性。要生成随机数，只需使用生成唯一签名的签名方案(如BLS)来签署一个种子，然后对签名进行哈希运算以生成公共随机数。要验证结果的随机性，请确保签名的哈希确实是随机数，并在种子上验证签名。

通过像计数器一样使用公共种子，可以扩展这种结构来产生许多随机数。因为签名是唯一的，并且公共种子是固定的，所以签名者无法生成不同的随机数。

运动

像BLS(图8.5和第7章中提到的)这样的签名方案产生唯一的签名，但是对于ECDSA和EdDSA来说，这是不正确的。你知道为什么吗？

为了解决这个问题，互联网草案(一个旨在成为RFC的文档)规定了如何使用ECDSA实现VRF。在某些情况下(例如，彩票游戏)，几个参与者可能想要随机决定一个赢家。我们称它们为*分散随机性信标*，因为它们的角色是产生相同的可验证的随机性，即使一些参与者决定不参与该协议。一种常见的解决方案是使用之前讨论的VRFs，不是使用单个密钥，而是使用*阈值分发密钥*，该密钥在许多参与者之间分割，并且仅在阈值参与者已经对消息签名之后才产生给定消息的唯一有效签名。这听起来可能有点混乱，因为这是我第一次谈论分布式密钥。要知道，在本章的后面，你会学到更多关于这些的知识。

一个受欢迎的分散随机信标叫做T2，由几个组织和大学联合运作。在https://leagueofentropy.com的T5有售。

*生成良好随机性的主要挑战是，参与随机性生成过程的任何一方都不能预测或偏向最终输出。一个drand网络不受其任何成员的控制。没有单点故障，没有一个drand服务器运营商能够偏向网络*产生的随机性。

——[https://drand . love](https://drand.love)(《drand如何运作》2021)

既然我已经广泛地讨论了随机性以及当今程序是如何获得随机性的，让我们将讨论转移到秘密在密码学中的作用以及如何管理它们。

## 8.6用HKDF导出密钥

prng并不是唯一可以用来从一个秘密推导出更多秘密的结构(换句话说，就是延伸一个密钥)。从一个秘密导出几个秘密实际上是密码学中如此频繁的模式，以至于这个概念有了自己的名字:*密钥导出*。让我们看看这是怎么回事。

一个*密钥派生函数* (KDF)在很多方面都像一个PRNG ，除了下面列出的一些细微之处。图8.6总结了这些差异。

*   *一个KDF不一定期望一个均匀随机的秘密(只要它有足够的熵)。*这使得KDF对于从密钥交换输出中导出秘密是有用的，密钥交换输出产生高熵但有偏见的结果(见第五章)。由此产生的秘密依次是一致随机的，因此您可以在期望一致随机密钥的构造中使用它们。

*   *KDF一般用在需要参与者多次重新驱动相同密钥的协议中。*在这个意义上，KDF被认为是确定性的，而PRNGs有时通过频繁地重新播种更多的熵来提供向后保密。

*   *一个KDF通常不是设计来产生大量随机数的。*取而代之的是，它通常用于导出有限数量的密钥。

![](../Images/08_06.png)

图8.6一个密钥衍生函数(KDF)和一个PRNG是两个相似的构造。主要区别在于，KDF不期望完全均匀随机的秘密作为输入(只要它有足够的熵),并且通常不用于产生太多的输出。

最流行的KDF是*基于HMAC的密钥派生函数* (HKDF)。你在第三章中学习了关于HMAC(一种基于散列函数的MAC)。HKDF是建立在HMAC之上的轻型KDF，在RFC 5869中定义。因此，可以将HKDF与不同的哈希函数一起使用，尽管它最常用于SHA-2。HKDF被指定为两个不同的函数:

*   *——HKDF提取*——从秘密输入中去除偏见，产生均匀随机的秘密。

*   *——HKDF扩展*——产生一个任意长度和均匀随机输出。像PRNGs一样，*期望一个均匀随机的秘密作为输入*，因此，通常在HKDF提取之后运行。

![](../Images/08_07.png)

图8.7 HKDF展开是HKDF指定的第二个函数。它需要一个可选的`info`字节字符串和一个需要均匀随机的输入秘密。使用具有相同输入密码的不同`info`字节字符串会产生不同的输出。输出的长度由一个`length`参数控制。

让我们先来看看HKDF摘录，我在图8.7中做了说明。从技术上讲，一个散列函数足以使输入字节串的随机性一致化(记住，散列函数的输出被认为是无法与随机区分的)，但是HKDF更进一步，接受了一个额外的输入:一个 *salt* 。关于密码哈希，一个salt区分了HKDF-Extract在同一个协议中的不同用法。虽然这个salt是可选的，如果不使用，它将被设置为全零字节字符串，但是我们建议您使用它。此外，HKDF不期望盐是一个秘密；每个人都可能知道，包括对手。HKDF-Extract没有使用散列函数，而是使用了MAC(特别是HMAC ),碰巧它有一个接受两个参数的接口。

现在让我们看看HKDF扩展，如图8.8所示。如果你的输入秘密已经是均匀随机的，你可以跳过HKDF提取，使用HKDF扩展。

![](../Images/08_08.png)

图8.8 HKDF提取是HKDF规定的第一个函数。它采用一个可选的salt作为HMAC中的密钥，并且输入秘密可能是非均匀随机的。使用具有相同输入秘密的不同盐会产生不同的输出。

与HKDF-Extract类似，HKDF-Expand也接受一个额外的可选定制参数`info`。虽然salt旨在为HKDF(或HKDF-Extract)的同一协议内的调用提供一些域分隔，但`info`旨在用于将您的HKDF(或HKDF-Expand)版本与其他协议区分开来。你也可以指定你想要多少输出，但是请记住，HKDF不是PRNG，也不是为了获取大量秘密而设计的。HKDF受到您使用的哈希函数大小的限制；更准确地说，如果您将SHA-512(它产生512位的输出)与HKDF一起使用，那么对于一个给定的键和一个`info`字节字符串，您只能得到512 × 255位= 16，320字节的输出。

使用相同的参数(除了输出长度)多次调用HKDF或HKDF-Expand，产生的相同输出被截断成不同的请求长度(见图8.9)。这个属性被称为*相关输出*，在极少数情况下，会让协议设计者感到惊讶。记住这一点是有好处的。

![](../Images/08_09.png)

图8.9 HKDF和HKDF展开提供了相关的输出，这意味着用不同的输出长度调用函数会将相同的结果截断到所要求的长度。

大多数密码库将HKDF提取和HKDF扩展组合成一个调用，如图8.10所示。像往常一样，在使用HKDF之前，确保阅读手册(在这种情况下，RFC 5869)。

![](../Images/08_10.png)

图8.10 HKDF通常被实现为一个单一的函数调用，结合了HKDF提取(从输入键中提取均匀的随机性)和HKDF扩展(生成任意长度的输出)。

HKDF并不是从一个秘密推导出多个秘密的唯一方法。一个更简单的方法是使用*哈希函数*。由于hash 函数不期望均匀随机的输入并产生均匀随机的输出，所以它们适合这个任务。然而，散列函数并不完美，因为它们的接口没有考虑到账户*域分隔*(没有定制字符串参数)，并且它们的输出长度是固定的。最佳实践是在可以使用KDF的情况下避免使用哈希函数。尽管如此，一些广为接受的算法确实为此使用了散列函数。例如，你在第7章中学习了Ed25519签名方案，它用SHA-512散列一个256位密钥来产生两个256位密钥。

这些函数真的会产生随机输出吗？

理论上，散列函数的属性并没有说输出是一致随机的；这些属性仅规定散列函数应该是抗冲突的、抗前映像的和抗第二前映像的。然而，在现实世界中，我们到处使用散列函数来实现随机预言(正如你在第2章中所学的)，因此，我们假设它们的输出是一致随机的。这与MAC是一样的，理论上，不期望MAC产生均匀随机输出(不像第3章中看到的PRF)，但实际上，在大多数情况下是这样的。这就是HKDF使用HMAC的原因。在本书的其余部分，我将假设流行的散列函数(如SHA-2和SHA-3)和流行的MAC(如HMAC和KMAC)产生随机输出。

我们在第2章(SHAKE和cSHAKE)中看到的扩展输出函数(xof)也可以用作KDF！记住，XOF

*   不期望均匀随机输入

*   可以产生几乎无限大的均匀随机输出

此外，KMAC(第三章中提到的MAC)没有我之前提到的相关输出问题。事实上，KMAC的长度参数使算法的输出随机化，实际上就像一个额外的定制字符串。

最后，对于具有低熵的输入，存在边缘情况。例如，考虑一下密码，与128位的密钥相比，它相对来说是可以猜测的。用于散列密码的基于密码的密钥派生函数(在第2章中介绍)也可以用于派生密钥。

## 8.7管理密钥和秘密

好了，都好了，我们知道如何生成加密随机数，我们知道如何在不同类型的情况下导出秘密。但是我们还没有脱离险境。

既然我们使用了所有这些加密算法，我们最终不得不维护大量的密钥。我们如何存放这些钥匙？我们如何防止这些极其敏感的秘密被泄露？如果秘密泄露了我们该怎么办？这个问题通常被称为*密钥管理*。

Crypto是一种工具，可以将一系列问题转化为密钥管理问题。

——阅读Kissner (2019年，[http://mng . BZ/emrj](http://mng.bz/eMrJ)

虽然许多系统选择将密钥放在使用它们的应用程序附近，但这并不一定意味着当坏事情发生时应用程序没有追索权。为了防范可能泄露密钥的最终漏洞或错误，大多数严肃的应用程序都采用两种深度防御技术:

*   *密钥轮换* —通过将到期日期与密钥(通常是公钥)相关联，并定期用新密钥替换您的密钥，您可以从最终的危害中“痊愈”。到期日期和轮换频率越短，就可以越快地替换攻击者可能知道的密钥。

*   *密钥撤销* —密钥轮换并不总是足够的，当你听到一个密钥已经被泄露时，你可能想要取消它。出于这个原因，一些系统允许您在使用密钥之前询问它是否已经被撤销。(在下一章“安全传输”中，你会学到更多。)

自动化往往是成功运用这些技术不可或缺的，因为一台运转良好的机器在危机时刻更容易正确工作。此外，您还可以将一个特定的角色与一个键相关联，以限制危害的后果。例如，您可以在一些虚构的应用程序中将两个公钥区分为公钥1和公钥2，前者仅用于签署事务，后者仅用于进行密钥交换。这使得与公钥2相关联的私钥的泄露不会影响交易签名。

如果不想将密钥留在设备存储介质上，存在旨在防止密钥被提取的硬件解决方案。你将在第13章硬件加密学中了解更多。

最后，应用程序可以通过多种方式来委托密钥管理。在移动操作系统上经常会出现这种情况，即提供*密钥库*或*密钥链*，它们会为你保存密钥，甚至会执行加密操作！

位于云中的应用程序有时可以访问云密钥管理服务。这些服务允许应用程序委托密钥和加密操作的创建，并避免考虑攻击它们的许多方法。尽管如此，与硬件解决方案一样，如果应用程序受到威胁，它仍然能够向委托服务发出任何类型的请求。

注意 没有灵丹妙药，你仍然应该考虑你能做些什么来检测和应对妥协。

密钥管理是一个难题，超出了本书的范围，所以我不会过多地讨论这个话题。在下一节中，我将介绍试图避免密钥管理问题的加密技术。

## 8.8使用门限加密技术分散信任

密钥管理是一个很大的研究领域，投资起来可能很烦人，因为用户并不总是有资源来实施最佳实践，也没有该领域中可用的工具。幸运的是，对于那些想减轻密钥管理负担的人来说，密码学有其可取之处。我要说的第一个是*秘密分享*(或者说*秘密分裂*)。秘密分割允许您将一个秘密分成多个部分，这些部分可以在一组参与者之间共享。在这里，秘密可以是您想要的任何东西:对称密钥、签名私钥等等。

典型的情况是，一个叫做*经销商*的人生成秘密，然后在删除秘密之前，将它分割并在所有参与者之间分享不同的部分。最著名的秘密分裂方案是由阿迪·萨莫尔(RSA的共同发明人之一)发明的，被称为*沙米尔的秘密共享* (SSS)的。我在图8.11中说明了这个过程。

![](../Images/08_11.png)

图8.11给定一个密钥和若干份额 *n* ，沙米尔的秘密共享方案创建 *n* 个与原密钥大小相同的部分密钥。

当需要秘密来执行一些密码操作(加密、签名等)时，所有的份额所有者需要将他们的私有份额归还给负责重构原始秘密的经销商。这种方案防止攻击者针对单个用户，因为每个共享本身是无用的，相反，迫使攻击者在利用密钥之前危害所有的参与者！我在图8.12中对此进行了说明。

![](../Images/08_12.png)

图8.12 sha mir的秘密共享方案用于在 *n* 部分密钥中分裂秘密，需要所有的 *n* 部分密钥来重构原始密钥。

该方案算法背后的数学原理其实并不难理解！因此，让我在这里抽出几个段落来给你一个简化的计划的想法。

想象一条二维空间上的随机直线，假设它的方程——*y*=*ax*+*b*——就是秘密。通过让两个参与者拿着线上的两个随机点，他们可以合作恢复线方程。该方案推广到任何次数的多项式，因此，可以用于将秘密分成任意数量的部分。这如图8.13所示。

![](../Images/08_13.png)

图the Shamir秘密共享方案背后的思想是将定义一条曲线的多项式视为秘密，将曲线上的随机点视为部分密钥。为了恢复定义一条曲线的次数为 *n* 的多项式，需要知道曲线上的 *n* + 1个点。比如*f*(*x*)= 3*x*+5是1次，那么你需要任意两点( *x* ， *f* ( *x* ))来恢复多项式，*f*(*x*)= 5*x*<sup class="fm-superscript">2</sup>+2

 *由于其简单性，秘密分割是一种经常被采用的技术。然而，为了有用，密钥部分必须被收集到一个地方，以便每次在加密操作中使用时重新创建密钥。这创造了一个机会之窗，在这个机会之窗中，秘密变得容易被窃取或意外泄露，实际上让我们回到了*单点故障*模型。为了避免这种单点故障问题，存在几种在不同场景中有用的加密技术。

例如，想象一个协议，该协议只接受已经由爱丽丝签名的金融交易。这给Alice带来了很大的负担，她可能害怕成为攻击者的目标。为了减少攻击对Alice的影响，我们可以改为(在同一事务中)接受来自 *n* 不同公钥的 *n* 个签名，包括Alice的。攻击者将不得不损害所有的 *n* 签名来伪造一个有效的交易！这种系统被称为多重签名，在加密货币领域被广泛采用。

然而，天真的多重签名方案会增加一些烦人的开销。事实上，在我们的示例中，事务的大小随着所需签名的数量而线性增长。为了解决这个问题，一些签名方案(如BLS签名方案)可以将几个签名压缩成一个。这就是所谓的*签名聚合*。一些多重签名方案在压缩方面走得更远，允许将 *n* 个公钥聚合成一个公钥。这种技术被称为*分布式密钥生成* (DKG)，是被称为*安全多方计算*的密码学领域的的一部分，我将在第15章中介绍。

DKG让 *n* 个参与者合作计算一个公钥，而在这个过程中没有相关的私钥(不像SSS，没有分发者)。如果参与者想要签署消息，他们可以使用每个参与者的私有份额协作创建签名，可以使用他们之前创建的公钥来验证该签名。同样，私钥实际上从不存在，防止了SSS的单点故障问题。因为你在第七章看到了施诺尔签名，图8.14显示了简化的施诺尔DKG方案背后的直觉。

![](../Images/08_14.png)

图8.14 schn orr签名方案可以分散成分布式密钥生成方案。

最后，注意

*   我提到的每一个方案都可以在只有n 个参与者中的一个阈值 *m* 参与协议时生效。这一点非常重要，因为大多数现实世界的系统都必须容忍大量恶意或不活跃的参与者。

*   这些类型的方案可以与其他非对称加密算法一起工作。例如，使用门限加密，一组参与者可以合作对消息进行非对称解密。

我在图8.15中回顾了所有这些例子。

![](../Images/08_15.png)

图8.15概述了将我们对一个参与者的信任分成几个参与者的现有技术。

门限方案是密钥管理领域中一个重要的新范例，跟踪它们的发展是一个好主意。NIST目前有一个门限密码组，该组组织研讨会，并打算长期标准化原语和协议。

## 总结

*   从一个集合中均匀随机地抽取一个数，如果它与该集合中的所有其他数相比以相等的概率被抽取。

*   熵是表示一个字节串有多少随机性的度量。高熵指的是均匀随机的字节串，而低熵指的是容易猜测或预测的字节串。

*   伪随机数发生器(PRNGs)是一种算法，它采用均匀随机的种子，并且(在实践中)生成几乎无限量的随机性，如果种子足够大，这些随机性可用于加密目的(例如，作为加密密钥)。

*   要获得随机数，应该依靠编程语言的标准库或众所周知的密码库。如果这些都不可用，操作系统通常会提供接口来获取随机数:

    *   Windows提供了`BCryptGenRandom`系统调用。
    *   Linux和FreeBSD提供了`getrandom`系统调用。
    *   其他类似Unix的操作系统通常有一个名为/dev/ urandom的特殊文件，它表现出随机性。
*   密钥导出函数(KDF)在想要从有偏差但高熵的秘密中导出秘密的场景中是有用的。

*   HKDF(基于HMAC的密钥派生函数)是使用最广泛的KDF，它基于HMAC。

*   密钥管理是保密领域，嗯，保密。它主要包括查找存储机密的位置、主动终止和轮换机密、确定机密泄露时该做什么等等。

*   为了减轻密钥管理的负担，可以将一个参与者的信任分成多个参与者。**